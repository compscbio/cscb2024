{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Computational Stem Cell Biology","text":"Level up <p>This is the compantion site for the course</p> <p>Its main purpose is to ease accessibility to the computational tutorials. All definitive material for the course, as well as links to videos, assined readings, etc, will be posted to Canvas. Please monitor your email and the Canvas page for notifications and changes in the course schedule.</p> <p>Biomedical Engineering 580.447/647  Computational Stem Cell Biology  Spring, 2024 (3 credits, EQ)</p>"},{"location":"index.html#education-team","title":"Education Team","text":""},{"location":"index.html#instructor-patrick-cahan","title":"Instructor: Patrick Cahan","text":""},{"location":"index.html#teaching-assistants-christine-miller-nadine-zureick","title":"Teaching Assistants: Christine Miller &amp; Nadine Zureick","text":""},{"location":"index.html#course-email-compscbiogmailcom","title":"Course email: compscbio@gmail.com","text":""},{"location":"index.html#office-hours","title":"Office hours","text":"<ul> <li>Patrick<ul> <li>Clark Hall 314B</li> <li>From the end of class to 2:30PM on Tuesdays and Thursdays, and by appointment.</li> </ul> </li> <li>Chistine and Nadine<ul> <li>Time and location TBA</li> </ul> </li> </ul>"},{"location":"index.html#class-meetings","title":"Class Meetings","text":"<ul> <li>12noon to 1:15 PM on Tuesdays and Thursdays</li> <li>Jan 23rd through April 25th</li> <li>No class March 19th or March 21st</li> <li>Shaffer Rm 304</li> <li>Zoom:<ul> <li>https://wse.zoom.us/j/92603318767</li> <li>Requires authentication via Hopkins SSO to join</li> </ul> </li> </ul>"},{"location":"index.html#online-resources","title":"Online resources","text":"<p>Please log in to Canvas for all materials related to this course, including reading assignments, lecture slides, lecture videos, Jupyter notebooks, homeworks, final project description, and announcements. </p>"},{"location":"index.html#course-information","title":"Course Information","text":"<p>This course teaches students about high-throughput, genome-wide single cell measurements, and approaches to appropriately analyze such data. Real world examples from stem cell biology and developmental biology provide the biological context and motivation, but the computational expertise gained will be broadly applicable. Please see the lecture schedule below for specific topics. The class is heavily weighted by computational assignments. The motivation for this strategy is that regularly occurring, moderately-sized computational projects are the most efficient way to impart an understanding of our models of this extraordinary class of cells, and to inspire a sense of excitement and empowerment in the students By the end of this course, the student should - be conversant in the language of sc-omics technologies, both at the level of general principles, and more granular understanding of how these data-generating platforms work - be a confident practioner in state-of-the art computational methods needed to analyze sc-omic data - understand the fundamentals of stem cell biology and to how sc-omics is allowing us to address major obstacles in this field</p>"},{"location":"index.html#recommended-background","title":"Recommended Background","text":"<p>EN.580.151 \u2013 Structural Biology of Cells , or equivalent, and prior hands on experience coding in Python . Please see some example homeworks from the 2022 course https://compscbio.github.io/ to assess your readiness for the class.</p>"},{"location":"index.html#course-goals","title":"Course Goals","text":"<p>This course will address the following Criterion 3 Student Outcomes - An ability to apply knowledge of mathematics, science and engineering to solve problems related to stem cell engineering</p> <ul> <li>An ability to analyze and interpret data using statistical, computational or mathematical methods</li> <li>An ability to function on multidisciplinary teams (Criteria 3(d))</li> <li>An understanding of professional and ethical responsibility (Criteria 3(f))</li> <li>An ability to communicate effectively (writing) (Criteria 3(g))</li> <li>An ability to communicate effectively (oral presentation) (Criteria 3(g))</li> </ul>"},{"location":"index.html#course-topics","title":"Course Topics","text":"<ul> <li>Stem cell biology</li> <li>single cell omics technologies</li> <li>computational tools for the analysis of single cell omics data</li> <li>Cell identity</li> <li>Pluripotency</li> <li>Gene regulatory networks</li> <li>Cell fate engineering</li> </ul>"},{"location":"index.html#ethics","title":"Ethics","text":"<p>The strength of the university depends on academic and personal integrity. In this course, you must be honest and truthful. Ethical violations include plagiarism, reuse of assignments, improper use of the Internet and electronic devices, unauthorized collaboration, alteration of graded assignments, forgery and falsification, lying, facilitating academic dishonesty, and unfair competition. In addition, the specific ethics guidelines for this course are: (1) The weekly paper summaries and the homeworks are to be completed by each student alone. Do not share your projects with other students or use material from prior years. (2) The use of Large language models (LLMs) such as  ChatGPT are allowed for the homeworks and final project, when doing so is consistent with the stated Course goals and Course expected outcomes (see above). The use of LLMs and similar technology is not allowed for the weekly written summaries. As a guideline, please use LLMs to augment your understanding of the material in the course, to help you to explore algorithmic ideas that might otherwise be challenging to implement, and more generally, to be a more creative problem solver. Report any violations you witness to the instructor.  You can find more information about university misconduct policies on the web at these sites: \u2022   For undergraduates: http://e-catalog.jhu.edu/undergrad-students/student-life-policies/ \u2022   For graduate students: http://e-catalog.jhu.edu/grad-students/graduate-specific-policies/</p>"},{"location":"index.html#grades","title":"Grades","text":"<ul> <li>In class participation: 5%<ul> <li>Asking questions and offering ideas during lecture counts.</li> <li>Other opportunties to garner particpation points will be announced during class.</li> <li>Please email Patrick and the TAs after class with a brief note reminding them of how you participated. </li> </ul> </li> <li>Weekly summarization of assigned reading: 10%<ul> <li>Each week you will be required to read a primary research paper, review article, or book chatper. Don't worry, this is not as bad as it might seem. Submit a brief write up about it. We expect these to be about one paragraph in length and to demonstrate that you did, in fact, read the assigned reading. The best write ups will discuss one specific aspect of the paper/chapter that the student found particularly interesting. Other good write ups are those that challenge claims made in the paper/chapter. </li> <li>Individual work; no LLMs, chatbots, etc.</li> </ul> </li> <li>Homeworks: 10% per homework. 60% total<ul> <li>Detailed expectations will be described for each HW</li> <li>Individual work; assistance from LLMs is allowed per guidelines in the Ethics section above.</li> </ul> </li> <li>Final project: 25%<ul> <li>Detailed expectations will be described for the project</li> <li>Small teams (2-3 students); assistance from LLMs is allowed per guidelines in the Ethics section above.</li> <li>Entails both a written submission and a live presentation</li> </ul> </li> <li>There are no quizzes, tests, or exams</li> <li>We have given opportunties for extra credit in past years and may do so this year</li> <li>Policy on grace periods and extensions: TBA</li> </ul>"},{"location":"lecture_schedule.html","title":"Lecture schedule","text":"<ol> <li>Course introduction and overview</li> <li>Stem cell fundamentals, cell identity, and gene expression </li> <li>How does scRNA-seq work?</li> <li>Fundamentals of scRNA-seq analysis (live analysis) <ol> <li>HW1 assigned</li> </ol> </li> <li>Data integration and cell typing</li> <li>Data integration and cell typing (live analysis) HW2 assigned</li> <li>Bio break: basics of development</li> <li>Pseudotime or trajectory inference</li> <li>Pseudotime analysis in practice (live analysis) HW3 assigned</li> <li>Biobreak: Mechanisms that maintain fate potency</li> <li>Cell potency calculators and lineage tracing</li> <li>Cell potency and lineage tracing analysis (live analysis) HW4 assigned</li> <li>Gene regulatory network inference from gene expression data</li> <li>ATAC-seq</li> <li>Regulatory network analysis (live analysis)</li> <li>Simulation engines and expression forecasting  HW5 assigned</li> <li>Simulation engines and expression forecasting (live analysis) Final project distributed</li> <li>Cell-cell interactions inference</li> <li>Cell-cell interaction (live analysis) HW6 assigned</li> <li>Spatial transcriptomics</li> <li>Spatial transcriptomics (live analysis) </li> <li>RNA velocity</li> <li>RNA velocity (live analysis)</li> <li>Controversies and ethical considerations</li> <li>Final group presentations</li> <li>Final group presentations</li> </ol>"},{"location":"notebooks/BCMB_121824_precheck.html","title":"BCMB Dec 2024: Pre-check","text":"BCMB and Immunology students: Before we meet on Wednesday morning 12/18/24, please ensure that you can access Google Colab as described below!  In\u00a0[\u00a0]: Copied!"},{"location":"notebooks/BCMB_121824_precheck.html#google-colab","title":"Google Colab\u00b6","text":"<p>You alread know about Jupyter and how to use it. In class, we will use Google's Colab cloud platform to perform analysis of scRNA-seq data. This platform allows users to run analyses on the cloud for free using Jupyter. But, you need a Google account to do so.</p> <ol> <li><p>Please create a Google account, if you do not already have one.</p> </li> <li><p>Log in to your Google account, if you are not already logged in.</p> </li> <li><p>Test your access to Google Colab. You should see a screen like the following:</p> </li> </ol> Screenshot of Colab diaglog box <ol> <li><p>Create a new notebook. If you see the dialog shown above, then click 'create notebook'. You can also create a notebook using the Menu at the top of the page: File -&gt; New notebook in Drive. Either will result in the launching of a new Jupyter notebook.</p> </li> <li><p>The End. You are done and can close the browser page on Colab.</p> </li> </ol>"},{"location":"notebooks/L4_scBasics.html","title":"scRNA-seq fundamentals","text":"Fundamentals of scRNA-seq analysis in Python Lecture 4, 02-01-2024 This notebook is part the course 580.447/647 Computational Stem Cell Biology taught by Patrick Cahan at Johns Hopkins University in Winter/Spring 2024. Many parts of this tutorial are derived from the sources listed in the Resources section at the end of this notebook. <p>Here is a more detailed glimpse of what is happening here:</p> CellRanger flow chart 2 from 10X genomics CellRanger mapping from 10X genomics In\u00a0[\u00a0]: Copied! <pre>!pip install scanpy scipy umap-learn leidenalg\n</pre> !pip install scanpy scipy umap-learn leidenalg In\u00a0[\u00a0]: Copied! <pre># wget for linux/unix\n# !wget https://cf.10xgenomics.com/samples/cell-exp/3.0.0/pbmc_10k_v3/pbmc_10k_v3_filtered_feature_bc_matrix.h5\n# !wget https://cf.10xgenomics.com/samples/cell-exp/6.1.0/20k_PBMC_3p_HT_nextgem_Chromium_X/20k_PBMC_3p_HT_nextgem_Chromium_X_filtered_feature_bc_matrix.h5\n\n# curl for macOS; i have no clue what to use for Windows\n!curl https://cf.10xgenomics.com/samples/cell-exp/3.0.0/pbmc_10k_v3/pbmc_10k_v3_filtered_feature_bc_matrix.h5 -o pbmc_10k_v3_filtered_feature_bc_matrix.h5\n!curl https://cf.10xgenomics.com/samples/cell-exp/6.1.0/20k_PBMC_3p_HT_nextgem_Chromium_X/20k_PBMC_3p_HT_nextgem_Chromium_X_filtered_feature_bc_matrix.h5 -o 20k_PBMC_3p_HT_nextgem_Chromium_X_filtered_feature_bc_matrix.h5\n</pre> # wget for linux/unix # !wget https://cf.10xgenomics.com/samples/cell-exp/3.0.0/pbmc_10k_v3/pbmc_10k_v3_filtered_feature_bc_matrix.h5 # !wget https://cf.10xgenomics.com/samples/cell-exp/6.1.0/20k_PBMC_3p_HT_nextgem_Chromium_X/20k_PBMC_3p_HT_nextgem_Chromium_X_filtered_feature_bc_matrix.h5  # curl for macOS; i have no clue what to use for Windows !curl https://cf.10xgenomics.com/samples/cell-exp/3.0.0/pbmc_10k_v3/pbmc_10k_v3_filtered_feature_bc_matrix.h5 -o pbmc_10k_v3_filtered_feature_bc_matrix.h5 !curl https://cf.10xgenomics.com/samples/cell-exp/6.1.0/20k_PBMC_3p_HT_nextgem_Chromium_X/20k_PBMC_3p_HT_nextgem_Chromium_X_filtered_feature_bc_matrix.h5 -o 20k_PBMC_3p_HT_nextgem_Chromium_X_filtered_feature_bc_matrix.h5 In\u00a0[3]: Copied! <pre>import scanpy as sc\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport warnings\nwarnings.filterwarnings('ignore')\nplt.rcParams['figure.dpi'] = 300\nsc.logging.print_header()\n</pre> import scanpy as sc import numpy as np import pandas as pd import matplotlib.pyplot as plt import warnings warnings.filterwarnings('ignore') plt.rcParams['figure.dpi'] = 300 sc.logging.print_header() <pre>scanpy==1.9.8 anndata==0.10.5.post1 umap==0.5.5 numpy==1.26.3 scipy==1.12.0 pandas==2.2.0 scikit-learn==1.4.0 statsmodels==0.14.1 igraph==0.11.3 pynndescent==0.5.11\n</pre> In\u00a0[4]: Copied! <pre># I have stored these data files in the directory data/ \nad10f = sc.read_10x_h5(\"data/pbmc_10k_v3_filtered_feature_bc_matrix.h5\")\n# If you stored yours in the cwd on Colab, you should uncomment and run this line instead to load your data:\n# ad10f = sc.read_10x_h5(\"pbmc_10k_v3_filtered_feature_bc_matrix.h5\")\n</pre> # I have stored these data files in the directory data/  ad10f = sc.read_10x_h5(\"data/pbmc_10k_v3_filtered_feature_bc_matrix.h5\") # If you stored yours in the cwd on Colab, you should uncomment and run this line instead to load your data: # ad10f = sc.read_10x_h5(\"pbmc_10k_v3_filtered_feature_bc_matrix.h5\") In\u00a0[5]: Copied! <pre>?sc.read_10x_h5\n</pre> ?sc.read_10x_h5 <pre>Signature:\nsc.read_10x_h5(\n    filename: 'Union[str, Path]',\n    genome: 'Optional[str]' = None,\n    gex_only: 'bool' = True,\n    backup_url: 'Optional[str]' = None,\n) -&gt; 'AnnData'\nDocstring:\nRead 10x-Genomics-formatted hdf5 file.\n\nParameters\n----------\nfilename : 'Union[str, Path]'\n    Path to a 10x hdf5 file.\ngenome : 'Optional[str]', optional (default: None)\n    Filter expression to genes within this genome. For legacy 10x h5\n    files, this must be provided if the data contains more than one genome.\ngex_only : 'bool', optional (default: True)\n    Only keep 'Gene Expression' data and ignore other feature types,\n    e.g. 'Antibody Capture', 'CRISPR Guide Capture', or 'Custom'\nbackup_url : 'Optional[str]', optional (default: None)\n    Retrieve the file from an URL if not present on disk.\n\nReturns\n-------\nAnnotated data matrix, where observations/cells are named by their\nbarcode and variables/genes by gene name. Stores the following information:\n\n:attr:`~anndata.AnnData.X`\n    The data matrix is stored\n:attr:`~anndata.AnnData.obs_names`\n    Cell names\n:attr:`~anndata.AnnData.var_names`\n    Gene names\n:attr:`~anndata.AnnData.var`\\ `['gene_ids']`\n    Gene IDs\n:attr:`~anndata.AnnData.var`\\ `['feature_types']`\n    Feature types\nFile:      /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs_material/lib/python3.12/site-packages/scanpy/readwrite.py\nType:      function</pre> In\u00a0[6]: Copied! <pre>print(ad10f)\n</pre> print(ad10f) <pre>AnnData object with n_obs \u00d7 n_vars = 11769 \u00d7 33538\n    var: 'gene_ids', 'feature_types', 'genome'\n</pre> In\u00a0[7]: Copied! <pre>ad10f.shape\n</pre> ad10f.shape Out[7]: <pre>(11769, 33538)</pre> In\u00a0[8]: Copied! <pre>type(ad10f)\n</pre> type(ad10f) Out[8]: <pre>anndata._core.anndata.AnnData</pre> In\u00a0[9]: Copied! <pre>ncells = 3\nngenes = 4\nrandGenes = np.random.choice(ad10f.var_names, size=ngenes, replace=False)\nrandCells = np.random.choice(ad10f.obs_names, size=ncells, replace=False)\n</pre> ncells = 3 ngenes = 4 randGenes = np.random.choice(ad10f.var_names, size=ngenes, replace=False) randCells = np.random.choice(ad10f.obs_names, size=ncells, replace=False) In\u00a0[10]: Copied! <pre>print(randCells)\n</pre> print(randCells) <pre>['CAGCAATGTGAGATCG-1' 'TCCGAAATCGAGTTGT-1' 'CACGGGTCACCAGGTC-1']\n</pre> In\u00a0[11]: Copied! <pre>print(randGenes)\n</pre> print(randGenes) <pre>['FADS6' 'NLRP13' 'KRTAP2-1' 'SSTR5']\n</pre> In\u00a0[12]: Copied! <pre>newAnndata = ad10f[ randCells ]\nnewAnndata\n</pre> newAnndata = ad10f[ randCells ] newAnndata Out[12]: <pre>View of AnnData object with n_obs \u00d7 n_vars = 3 \u00d7 33538\n    var: 'gene_ids', 'feature_types', 'genome'</pre> In\u00a0[13]: Copied! <pre>ad10f[ randGenes ]\n</pre> ad10f[ randGenes ] <pre>\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nCell In[13], line 1\n----&gt; 1 ad10f[ randGenes ]\n\nFile /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs_material/lib/python3.12/site-packages/anndata/_core/anndata.py:1177, in AnnData.__getitem__(self, index)\n   1175 def __getitem__(self, index: Index) -&gt; AnnData:\n   1176     \"\"\"Returns a sliced view of the object.\"\"\"\n-&gt; 1177     oidx, vidx = self._normalize_indices(index)\n   1178     return AnnData(self, oidx=oidx, vidx=vidx, asview=True)\n\nFile /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs_material/lib/python3.12/site-packages/anndata/_core/anndata.py:1158, in AnnData._normalize_indices(self, index)\n   1157 def _normalize_indices(self, index: Index | None) -&gt; tuple[slice, slice]:\n-&gt; 1158     return _normalize_indices(index, self.obs_names, self.var_names)\n\nFile /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs_material/lib/python3.12/site-packages/anndata/_core/index.py:35, in _normalize_indices(index, names0, names1)\n     33         index = index[0].values, index[1]\n     34 ax0, ax1 = unpack_index(index)\n---&gt; 35 ax0 = _normalize_index(ax0, names0)\n     36 ax1 = _normalize_index(ax1, names1)\n     37 return ax0, ax1\n\nFile /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs_material/lib/python3.12/site-packages/anndata/_core/index.py:101, in _normalize_index(indexer, index)\n     99         if np.any(positions &lt; 0):\n    100             not_found = indexer[positions &lt; 0]\n--&gt; 101             raise KeyError(\n    102                 f\"Values {list(not_found)}, from {list(indexer)}, \"\n    103                 \"are not valid obs/ var names or indices.\"\n    104             )\n    105         return positions  # np.ndarray[int]\n    106 else:\n\nKeyError: \"Values ['FADS6', 'NLRP13', 'KRTAP2-1', 'SSTR5'], from ['FADS6', 'NLRP13', 'KRTAP2-1', 'SSTR5'], are not valid obs/ var names or indices.\"</pre> In\u00a0[14]: Copied! <pre>ad10f[:, randGenes ]\n</pre> ad10f[:, randGenes ] <pre>\n---------------------------------------------------------------------------\nInvalidIndexError                         Traceback (most recent call last)\nCell In[14], line 1\n----&gt; 1 ad10f[:, randGenes ]\n\nFile /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs_material/lib/python3.12/site-packages/anndata/_core/anndata.py:1177, in AnnData.__getitem__(self, index)\n   1175 def __getitem__(self, index: Index) -&gt; AnnData:\n   1176     \"\"\"Returns a sliced view of the object.\"\"\"\n-&gt; 1177     oidx, vidx = self._normalize_indices(index)\n   1178     return AnnData(self, oidx=oidx, vidx=vidx, asview=True)\n\nFile /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs_material/lib/python3.12/site-packages/anndata/_core/anndata.py:1158, in AnnData._normalize_indices(self, index)\n   1157 def _normalize_indices(self, index: Index | None) -&gt; tuple[slice, slice]:\n-&gt; 1158     return _normalize_indices(index, self.obs_names, self.var_names)\n\nFile /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs_material/lib/python3.12/site-packages/anndata/_core/index.py:36, in _normalize_indices(index, names0, names1)\n     34 ax0, ax1 = unpack_index(index)\n     35 ax0 = _normalize_index(ax0, names0)\n---&gt; 36 ax1 = _normalize_index(ax1, names1)\n     37 return ax0, ax1\n\nFile /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs_material/lib/python3.12/site-packages/anndata/_core/index.py:98, in _normalize_index(indexer, index)\n     96     return positions  # np.ndarray[int]\n     97 else:  # indexer should be string array\n---&gt; 98     positions = index.get_indexer(indexer)\n     99     if np.any(positions &lt; 0):\n    100         not_found = indexer[positions &lt; 0]\n\nFile /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs_material/lib/python3.12/site-packages/pandas/core/indexes/base.py:3882, in Index.get_indexer(self, target, method, limit, tolerance)\n   3879 self._check_indexing_method(method, limit, tolerance)\n   3881 if not self._index_as_unique:\n-&gt; 3882     raise InvalidIndexError(self._requires_unique_msg)\n   3884 if len(target) == 0:\n   3885     return np.array([], dtype=np.intp)\n\nInvalidIndexError: Reindexing only valid with uniquely valued Index objects</pre> In\u00a0[15]: Copied! <pre>gname_counts = ad10f.var_names.value_counts()\nnp.any(gname_counts&gt;1)\n</pre> gname_counts = ad10f.var_names.value_counts() np.any(gname_counts&gt;1) Out[15]: <pre>True</pre> In\u00a0[16]: Copied! <pre>duplicates = gname_counts[gname_counts &gt; 1]\nprint(duplicates)\n</pre> duplicates = gname_counts[gname_counts &gt; 1] print(duplicates) <pre>PDE11A       2\nSCO2         2\nLINC01505    2\nPRSS50       2\nATXN7        2\nEMG1         2\nCYB561D2     2\nLINC01238    2\nCCDC39       2\nTXNRD3NB     2\nABCF2        2\nHSPA14       2\nTBCE         2\nSOD2         2\nRGS5         2\nTMSB15B      2\nMATR3        2\nPINX1        2\nPOLR2J3      2\nDIABLO       2\nLINC02203    2\nIGF2         2\nH2BFS        2\nCOG8         2\nName: count, dtype: int64\n</pre> In\u00a0[17]: Copied! <pre>ad10f.var_names_make_unique()\nad10f[:, randGenes ]\n</pre> ad10f.var_names_make_unique() ad10f[:, randGenes ] Out[17]: <pre>View of AnnData object with n_obs \u00d7 n_vars = 11769 \u00d7 4\n    var: 'gene_ids', 'feature_types', 'genome'</pre> In\u00a0[18]: Copied! <pre>ad10f[randCells, randGenes ]\n</pre> ad10f[randCells, randGenes ] Out[18]: <pre>View of AnnData object with n_obs \u00d7 n_vars = 3 \u00d7 4\n    var: 'gene_ids', 'feature_types', 'genome'</pre> Views Views are pointers to memory where original anndata is stored. They are _not_ copies of the variable.   In\u00a0[19]: Copied! <pre>ad10f[randCells, randGenes ].X\n</pre> ad10f[randCells, randGenes ].X Out[19]: <pre>&lt;3x4 sparse matrix of type '&lt;class 'numpy.float32'&gt;'\n\twith 0 stored elements in Compressed Sparse Row format&gt;</pre> In\u00a0[20]: Copied! <pre>print(ad10f.obs.columns)\n</pre> print(ad10f.obs.columns) <pre>Index([], dtype='object')\n</pre> In\u00a0[21]: Copied! <pre>ad10f.obs['sample_name'] = \"sample_1\"\nprint(ad10f.obs.columns)\n</pre> ad10f.obs['sample_name'] = \"sample_1\" print(ad10f.obs.columns) <pre>Index(['sample_name'], dtype='object')\n</pre> In\u00a0[22]: Copied! <pre>print(ad10f[randCells].obs)\n</pre> print(ad10f[randCells].obs) <pre>                   sample_name\nCAGCAATGTGAGATCG-1    sample_1\nTCCGAAATCGAGTTGT-1    sample_1\nCACGGGTCACCAGGTC-1    sample_1\n</pre> In\u00a0[23]: Copied! <pre>print(ad10f.var.columns)\n</pre> print(ad10f.var.columns) <pre>Index(['gene_ids', 'feature_types', 'genome'], dtype='object')\n</pre> In\u00a0[24]: Copied! <pre>print(ad10f[:,randGenes].var)\n</pre> print(ad10f[:,randGenes].var) <pre>                 gene_ids    feature_types  genome\nFADS6     ENSG00000172782  Gene Expression  GRCh38\nNLRP13    ENSG00000173572  Gene Expression  GRCh38\nKRTAP2-1  ENSG00000212725  Gene Expression  GRCh38\nSSTR5     ENSG00000162009  Gene Expression  GRCh38\n</pre> In\u00a0[23]: Copied! <pre>print(ad10f.var[randGenes,:])\n</pre> print(ad10f.var[randGenes,:]) <pre>\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nFile /opt/homebrew/Caskroom/miniforge/base/envs/pyscn_v3/lib/python3.11/site-packages/pandas/core/indexes/base.py:3790, in Index.get_loc(self, key)\n   3789 try:\n-&gt; 3790     return self._engine.get_loc(casted_key)\n   3791 except KeyError as err:\n\nFile index.pyx:152, in pandas._libs.index.IndexEngine.get_loc()\n\nFile index.pyx:158, in pandas._libs.index.IndexEngine.get_loc()\n\nTypeError: '(array(['PREP', 'AL589986.1', 'AC245140.3', 'AL445228.1'], dtype=object), slice(None, None, None))' is an invalid key\n\nDuring handling of the above exception, another exception occurred:\n\nInvalidIndexError                         Traceback (most recent call last)\nCell In[23], line 1\n----&gt; 1 print(ad10f.var[randGenes,:])\n\nFile /opt/homebrew/Caskroom/miniforge/base/envs/pyscn_v3/lib/python3.11/site-packages/pandas/core/frame.py:3896, in DataFrame.__getitem__(self, key)\n   3894 if self.columns.nlevels &gt; 1:\n   3895     return self._getitem_multilevel(key)\n-&gt; 3896 indexer = self.columns.get_loc(key)\n   3897 if is_integer(indexer):\n   3898     indexer = [indexer]\n\nFile /opt/homebrew/Caskroom/miniforge/base/envs/pyscn_v3/lib/python3.11/site-packages/pandas/core/indexes/base.py:3802, in Index.get_loc(self, key)\n   3797     raise KeyError(key) from err\n   3798 except TypeError:\n   3799     # If we have a listlike key, _check_indexing_error will raise\n   3800     #  InvalidIndexError. Otherwise we fall through and re-raise\n   3801     #  the TypeError.\n-&gt; 3802     self._check_indexing_error(key)\n   3803     raise\n\nFile /opt/homebrew/Caskroom/miniforge/base/envs/pyscn_v3/lib/python3.11/site-packages/pandas/core/indexes/base.py:5974, in Index._check_indexing_error(self, key)\n   5970 def _check_indexing_error(self, key):\n   5971     if not is_scalar(key):\n   5972         # if key is not a scalar, directly raise an error (the code below\n   5973         # would convert to numpy arrays and raise later any way) - GH29926\n-&gt; 5974         raise InvalidIndexError(key)\n\nInvalidIndexError: (array(['PREP', 'AL589986.1', 'AC245140.3', 'AL445228.1'], dtype=object), slice(None, None, None))</pre> In\u00a0[25]: Copied! <pre>print(ad10f.var.loc[randGenes])\n</pre> print(ad10f.var.loc[randGenes]) <pre>                 gene_ids    feature_types  genome\nFADS6     ENSG00000172782  Gene Expression  GRCh38\nNLRP13    ENSG00000173572  Gene Expression  GRCh38\nKRTAP2-1  ENSG00000212725  Gene Expression  GRCh38\nSSTR5     ENSG00000162009  Gene Expression  GRCh38\n</pre> In\u00a0[26]: Copied! <pre>ad10f.var['mt'] = ad10f.var_names.str.startswith('MT-')\nribo_prefix = (\"RPS\",\"RPL\")\nad10f.var['ribo'] = ad10f.var_names.str.startswith(ribo_prefix)\nsc.pp.calculate_qc_metrics(ad10f, qc_vars=['mt','ribo'], percent_top=None, log1p=False, inplace=True)\n</pre> ad10f.var['mt'] = ad10f.var_names.str.startswith('MT-') ribo_prefix = (\"RPS\",\"RPL\") ad10f.var['ribo'] = ad10f.var_names.str.startswith(ribo_prefix) sc.pp.calculate_qc_metrics(ad10f, qc_vars=['mt','ribo'], percent_top=None, log1p=False, inplace=True) In\u00a0[27]: Copied! <pre>adClean = ad10f.copy()\n\nfig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(10,4), gridspec_kw={'wspace':0.25}, constrained_layout=True)\nax1_dict = sc.pl.scatter(adClean, x='total_counts', y='pct_counts_mt', ax=ax1, show=False)\nax2_dict = sc.pl.scatter(adClean, x='total_counts', y='n_genes_by_counts',ax=ax2, show=False)\nax3_dict = sc.pl.scatter(adClean, x='pct_counts_ribo', y='n_genes_by_counts',ax=ax3, show=False)\nplt.show()\n</pre> adClean = ad10f.copy()  fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(10,4), gridspec_kw={'wspace':0.25}, constrained_layout=True) ax1_dict = sc.pl.scatter(adClean, x='total_counts', y='pct_counts_mt', ax=ax1, show=False) ax2_dict = sc.pl.scatter(adClean, x='total_counts', y='n_genes_by_counts',ax=ax2, show=False) ax3_dict = sc.pl.scatter(adClean, x='pct_counts_ribo', y='n_genes_by_counts',ax=ax3, show=False) plt.show() <p>Now, do the filtering. First, keep only cells with &lt; 20% mitochonrially encoded gene total UMIs</p> In\u00a0[28]: Copied! <pre>adClean = adClean[adClean.obs['pct_counts_mt']&lt;20,:].copy()\nadClean.n_obs\n</pre> adClean = adClean[adClean.obs['pct_counts_mt']&lt;20,:].copy() adClean.n_obs Out[28]: <pre>11047</pre> <p>Now filter based on total number of genes detected (at least 500) and total number of counts (less than 30,000). And keep genes that are detected in at least 3 cells.</p> In\u00a0[29]: Copied! <pre>sc.pp.filter_cells(adClean, min_genes=500)\nsc.pp.filter_cells(adClean, max_counts=30000)\nsc.pp.filter_genes(adClean, min_cells=3)\nadClean.shape\n</pre> sc.pp.filter_cells(adClean, min_genes=500) sc.pp.filter_cells(adClean, max_counts=30000) sc.pp.filter_genes(adClean, min_cells=3) adClean.shape Out[29]: <pre>(10891, 20181)</pre> In\u00a0[83]: Copied! <pre>adNorm = adClean.copy()\nsc.pp.normalize_total(adNorm , target_sum=1e4)\nsc.pp.log1p(adNorm )\n</pre> adNorm = adClean.copy() sc.pp.normalize_total(adNorm , target_sum=1e4) sc.pp.log1p(adNorm ) In\u00a0[84]: Copied! <pre>sc.pp.highly_variable_genes(adNorm , min_mean=0.0125, max_mean=6, min_disp=0.25)\nadNorm.var\n</pre> sc.pp.highly_variable_genes(adNorm , min_mean=0.0125, max_mean=6, min_disp=0.25) adNorm.var Out[84]: gene_ids feature_types genome mt ribo n_cells_by_counts mean_counts pct_dropout_by_counts total_counts n_cells highly_variable means dispersions dispersions_norm AL627309.1 ENSG00000238009 Gene Expression GRCh38 False False 60 0.005183 99.490186 61.0 60 False 0.007519 0.595591 -0.001919 AL627309.3 ENSG00000239945 Gene Expression GRCh38 False False 4 0.000340 99.966012 4.0 4 False 0.000389 0.144284 -1.366927 AL669831.5 ENSG00000237491 Gene Expression GRCh38 False False 679 0.062367 94.230606 734.0 665 False 0.077585 0.586329 -0.029932 FAM87B ENSG00000177757 Gene Expression GRCh38 False False 13 0.001190 99.889540 14.0 13 False 0.001139 0.169543 -1.290532 LINC00115 ENSG00000225880 Gene Expression GRCh38 False False 350 0.031269 97.026085 368.0 337 False 0.038579 0.459107 -0.414723 ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... AC011043.1 ENSG00000276256 Gene Expression GRCh38 False False 77 0.006882 99.345739 81.0 74 False 0.010262 0.738345 0.429851 AL592183.1 ENSG00000273748 Gene Expression GRCh38 False False 32 0.002719 99.728099 32.0 30 False 0.003977 0.799225 0.613985 AC007325.4 ENSG00000278817 Gene Expression GRCh38 False False 239 0.020902 97.969241 246.0 233 False 0.023936 0.329110 -0.807909 AL354822.1 ENSG00000278384 Gene Expression GRCh38 False False 319 0.028210 97.289489 332.0 303 False 0.038089 0.594378 -0.005588 AC240274.1 ENSG00000271254 Gene Expression GRCh38 False False 101 0.008752 99.141813 103.0 99 False 0.010213 0.301150 -0.892475 <p>20181 rows \u00d7 14 columns</p> In\u00a0[85]: Copied! <pre>sc.pl.highly_variable_genes(adNorm)\n</pre> sc.pl.highly_variable_genes(adNorm) In\u00a0[86]: Copied! <pre>sc.tl.pca(adNorm , use_highly_variable=True)\n</pre> sc.tl.pca(adNorm , use_highly_variable=True) In\u00a0[87]: Copied! <pre>markerGenes = ['CD14','CLEC4C', 'CD19',  'GNLY', 'CD3D']\nsc.pl.pca(adNorm , color=markerGenes, ncols=2)\n</pre> markerGenes = ['CD14','CLEC4C', 'CD19',  'GNLY', 'CD3D'] sc.pl.pca(adNorm , color=markerGenes, ncols=2) In\u00a0[35]: Copied! <pre>sc.pl.pca(adNorm, color=['total_counts', 'pct_counts_mt', 'pct_counts_ribo'], s=25,ncols=3)\n</pre> sc.pl.pca(adNorm, color=['total_counts', 'pct_counts_mt', 'pct_counts_ribo'], s=25,ncols=3) In\u00a0[36]: Copied! <pre>sc.pl.pca_variance_ratio(adNorm, 50)\n</pre> sc.pl.pca_variance_ratio(adNorm, 50) In\u00a0[88]: Copied! <pre>np.shape(adNorm.varm[\"PCs\"])\n</pre> np.shape(adNorm.varm[\"PCs\"]) Out[88]: <pre>(20181, 50)</pre> <p>Where are the PC values of each cell (i.e. the PC scores) stored in anndata? .obsm</p> In\u00a0[89]: Copied! <pre>np.shape(adNorm.obsm[\"X_pca\"])\n</pre> np.shape(adNorm.obsm[\"X_pca\"]) Out[89]: <pre>(10891, 50)</pre> In\u00a0[90]: Copied! <pre>n_neighbors = 20\nn_pcs = 10\nsc.pp.neighbors(adNorm, n_neighbors=n_neighbors, n_pcs=n_pcs)\n</pre> n_neighbors = 20 n_pcs = 10 sc.pp.neighbors(adNorm, n_neighbors=n_neighbors, n_pcs=n_pcs) In\u00a0[91]: Copied! <pre>sc.tl.umap(adNorm, 0.25)\n</pre> sc.tl.umap(adNorm, 0.25) In\u00a0[92]: Copied! <pre>sc.pl.umap(adNorm, color=markerGenes, alpha=.75, s=15, ncols=2)\n</pre> sc.pl.umap(adNorm, color=markerGenes, alpha=.75, s=15, ncols=2) In\u00a0[93]: Copied! <pre>sc.tl.leiden(adNorm,.1)\n</pre> sc.tl.leiden(adNorm,.1) In\u00a0[94]: Copied! <pre>sc.pl.umap(adNorm,color=['leiden'], alpha=.75, s=15, legend_loc='on data')\n</pre> sc.pl.umap(adNorm,color=['leiden'], alpha=.75, s=15, legend_loc='on data') Discordance Embeddings do not always agree with cluster results! See cluster 4 above, and note in particular one cell from cluster '1' that is embedded next to the island part of cluster '4'.   <p>We can try to rectify this by using PAGA, which tries to infer dynamic relationships between clusters, to seed an initial embedding for UMAP that reflects overall cluster similarities.</p> <p>In the next cell, we call the following functions</p> <p><code>tl.paga()</code> computes intercluster similarities</p> <p><code>pl.paga()</code> creates an intial embedding based on this</p> <p><code>tl.umap()</code> uses this embedding to start its optimization</p> <p>Let's restart with the cleaned data.</p> In\u00a0[111]: Copied! <pre>adNorm = adClean.copy()\n\n## Norm, HVG, PCA, kNN\nsc.pp.normalize_total(adNorm , target_sum=1e4)\nsc.pp.log1p(adNorm)\nsc.pp.highly_variable_genes(adNorm , min_mean=0.0125, max_mean=6, min_disp=0.25)\nsc.tl.pca(adNorm , use_highly_variable=True)\n\nn_neighbors = 20\nn_pcs = 10\nsc.pp.neighbors(adNorm, n_neighbors=n_neighbors, n_pcs=n_pcs)\nsc.tl.leiden(adNorm,.1)\nsc.tl.paga(adNorm)\nsc.pl.paga(adNorm, plot=False)\nsc.tl.umap(adNorm, 0.25, init_pos='paga')\nsc.pl.umap(adNorm,color=['leiden'], alpha=.75, s=15, legend_loc='on data')\n</pre> adNorm = adClean.copy()  ## Norm, HVG, PCA, kNN sc.pp.normalize_total(adNorm , target_sum=1e4) sc.pp.log1p(adNorm) sc.pp.highly_variable_genes(adNorm , min_mean=0.0125, max_mean=6, min_disp=0.25) sc.tl.pca(adNorm , use_highly_variable=True)  n_neighbors = 20 n_pcs = 10 sc.pp.neighbors(adNorm, n_neighbors=n_neighbors, n_pcs=n_pcs) sc.tl.leiden(adNorm,.1) sc.tl.paga(adNorm) sc.pl.paga(adNorm, plot=False) sc.tl.umap(adNorm, 0.25, init_pos='paga') sc.pl.umap(adNorm,color=['leiden'], alpha=.75, s=15, legend_loc='on data') In\u00a0[112]: Copied! <pre>sc.pl.umap(adNorm , color=markerGenes, ncols=2)\n</pre> sc.pl.umap(adNorm , color=markerGenes, ncols=2) <p>Make a figure that shows the embedding and expression of marker genes side-by-side. Note that I am adding markers for T cell, B cell, and Monocyte sub-types</p> In\u00a0[114]: Copied! <pre>marker_genes_broad_dict = {\n    'B cell': ['CD79A', 'PAX5'],\n    'Dendritic': ['CLEC4C', 'FCER1A'],\n    'Monocyte': ['CSF1R', 'FCGR3A'],\n    'NK cell': ['NKG7', 'GNLY'],\n    'T cell': ['TRAC', 'CD3E'],\n}\n\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,4), gridspec_kw={'wspace':0.25})\nax1_dict = sc.pl.umap(adNorm,color=['leiden'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False)\nax2_dict = sc.pl.dotplot(adNorm, marker_genes_broad_dict, 'leiden', dendrogram=True,ax=ax2, show=False)\nplt.show()\n</pre> marker_genes_broad_dict = {     'B cell': ['CD79A', 'PAX5'],     'Dendritic': ['CLEC4C', 'FCER1A'],     'Monocyte': ['CSF1R', 'FCGR3A'],     'NK cell': ['NKG7', 'GNLY'],     'T cell': ['TRAC', 'CD3E'], }  fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,4), gridspec_kw={'wspace':0.25}) ax1_dict = sc.pl.umap(adNorm,color=['leiden'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False) ax2_dict = sc.pl.dotplot(adNorm, marker_genes_broad_dict, 'leiden', dendrogram=True,ax=ax2, show=False) plt.show() <pre>WARNING: Groups are not reordered because the `groupby` categories and the `var_group_labels` are different.\ncategories: 0, 1, 2, etc.\nvar_group_labels: B cell, Dendritic, Monocyte, etc.\n</pre> In\u00a0[115]: Copied! <pre>sc.tl.leiden(adNorm,.1, restrict_to=[\"leiden\",[\"5\"]])\nsc.tl.dendrogram(adNorm, \"leiden_R\")\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,4), gridspec_kw={'wspace':0.25})\nax1_dict = sc.pl.umap(adNorm,color=['leiden_R'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False)\nax2_dict = sc.pl.dotplot(adNorm, marker_genes_broad_dict, 'leiden_R', dendrogram=True,ax=ax2, show=False)\nplt.show()\n</pre> sc.tl.leiden(adNorm,.1, restrict_to=[\"leiden\",[\"5\"]]) sc.tl.dendrogram(adNorm, \"leiden_R\") fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,4), gridspec_kw={'wspace':0.25}) ax1_dict = sc.pl.umap(adNorm,color=['leiden_R'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False) ax2_dict = sc.pl.dotplot(adNorm, marker_genes_broad_dict, 'leiden_R', dendrogram=True,ax=ax2, show=False) plt.show() <pre>WARNING: Groups are not reordered because the `groupby` categories and the `var_group_labels` are different.\ncategories: 0, 1, 2, etc.\nvar_group_labels: B cell, Dendritic, Monocyte, etc.\n</pre> <p>Cluster 5 is split into 2 clusters now. Both of these sub-clusters express the Monocyte marker CD14, but are distinguished by their expression of dendritic marker FCER1A and the B cell genes CD79A and PAX5. Let's look at the QC metrics to see if that can give us additional hints as to whether these are real cells or are doublets.</p> In\u00a0[116]: Copied! <pre>sc.pl.violin(adNorm, ['total_counts'], groupby='leiden' )\n</pre> sc.pl.violin(adNorm, ['total_counts'], groupby='leiden' ) <p>Cluster 5 has a high number of Total counts. So let's annotate these as 'doublet'.</p> <p>What about the other questionable clusters 4 and 2? Can we refine those?</p> In\u00a0[117]: Copied! <pre>sc.tl.leiden(adNorm,.1, restrict_to=[\"leiden\",[\"2\"]])\nsc.tl.dendrogram(adNorm, \"leiden_R\")\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,4), gridspec_kw={'wspace':0.25})\nax1_dict = sc.pl.umap(adNorm,color=['leiden_R'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False)\nax2_dict = sc.pl.dotplot(adNorm, marker_genes_broad_dict, 'leiden_R', dendrogram=True,ax=ax2, show=False)\nplt.show()\n</pre> sc.tl.leiden(adNorm,.1, restrict_to=[\"leiden\",[\"2\"]]) sc.tl.dendrogram(adNorm, \"leiden_R\") fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,4), gridspec_kw={'wspace':0.25}) ax1_dict = sc.pl.umap(adNorm,color=['leiden_R'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False) ax2_dict = sc.pl.dotplot(adNorm, marker_genes_broad_dict, 'leiden_R', dendrogram=True,ax=ax2, show=False) plt.show() <pre>WARNING: Groups are not reordered because the `groupby` categories and the `var_group_labels` are different.\ncategories: 0, 1, 2,0, etc.\nvar_group_labels: B cell, Dendritic, Monocyte, etc.\n</pre> <p>It looks like 2,0 is T cell, and 2,1 is Natural Killer cell. Note that 2,0 still has a distinct profile as compared to 0.</p> <p>What about cluster 4? And this time, when we do the sub-clustering, let's keep the way that we split up cluster 2.</p> In\u00a0[118]: Copied! <pre>sc.tl.leiden(adNorm,.1, restrict_to=[\"leiden_R\",[\"4\"]])\nsc.tl.dendrogram(adNorm, \"leiden_R\")\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,4), gridspec_kw={'wspace':0.25})\nax1_dict = sc.pl.umap(adNorm,color=['leiden_R'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False)\nax2_dict = sc.pl.dotplot(adNorm, marker_genes_broad_dict, 'leiden_R', dendrogram=True,ax=ax2, show=False)\nplt.show()\n</pre> sc.tl.leiden(adNorm,.1, restrict_to=[\"leiden_R\",[\"4\"]]) sc.tl.dendrogram(adNorm, \"leiden_R\") fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,4), gridspec_kw={'wspace':0.25}) ax1_dict = sc.pl.umap(adNorm,color=['leiden_R'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False) ax2_dict = sc.pl.dotplot(adNorm, marker_genes_broad_dict, 'leiden_R', dendrogram=True,ax=ax2, show=False) plt.show() <pre>WARNING: Groups are not reordered because the `groupby` categories and the `var_group_labels` are different.\ncategories: 0, 1, 2,0, etc.\nvar_group_labels: B cell, Dendritic, Monocyte, etc.\n</pre> <p>Is 4,1 multiplet?</p> In\u00a0[119]: Copied! <pre>sc.pl.violin(adNorm, ['total_counts', 'n_genes_by_counts'], groupby='leiden_R' )\n</pre> sc.pl.violin(adNorm, ['total_counts', 'n_genes_by_counts'], groupby='leiden_R' ) <p>Yes, it looks like 4,1 is similar in these QC profiles to cluster 5.</p> <p>So our updated annotation table is now:</p> cluster markers  of cell type 5 B, Dendritic, Mono doublet 1 Monocyte Monocyte 4,0 Monocyte Monocyte 3 B B-cell 6 Dendritic (B/Mono?) Dendritic cell 7 none Mystery cell 0 T cell T cell 2,0 T cell T cell 2,1 NK cell NK cell <p>Why do we have two Monocyte clusters and two T cells clusters?</p> In\u00a0[120]: Copied! <pre>marker_genes_sub_dict = {\n    'B cell': ['CD79A'],\n    'Dendritic': ['CLEC4C'],\n    'CD14 monocyte': ['CD14'],\n    'CD16 monocyte': ['FCGR3A'],\n    'NK cell': ['GNLY'],\n    'CD4 T cell': ['CD4', 'GATA3'],\n    'CD8 T cell': ['CD8A', 'EOMES']\n}\n\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,4), gridspec_kw={'wspace':0.25})\nax1_dict = sc.pl.umap(adNorm,color=['leiden_R'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False)\nax2_dict = sc.pl.dotplot(adNorm, marker_genes_sub_dict, 'leiden_R', dendrogram=True,ax=ax2, show=False)\nplt.show()\n</pre> marker_genes_sub_dict = {     'B cell': ['CD79A'],     'Dendritic': ['CLEC4C'],     'CD14 monocyte': ['CD14'],     'CD16 monocyte': ['FCGR3A'],     'NK cell': ['GNLY'],     'CD4 T cell': ['CD4', 'GATA3'],     'CD8 T cell': ['CD8A', 'EOMES'] }  fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,4), gridspec_kw={'wspace':0.25}) ax1_dict = sc.pl.umap(adNorm,color=['leiden_R'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False) ax2_dict = sc.pl.dotplot(adNorm, marker_genes_sub_dict, 'leiden_R', dendrogram=True,ax=ax2, show=False) plt.show() <pre>WARNING: Groups are not reordered because the `groupby` categories and the `var_group_labels` are different.\ncategories: 0, 1, 2,0, etc.\nvar_group_labels: B cell, Dendritic, CD14 monocyte, etc.\n</pre> <p>We are close to a final annotation now:</p> cluster markers  of cell type 5 B, Dendritic, Mono doublet 1 Monocyte CD14 Monocyte 4,0 Monocyte CD16 Monocyte 3 B B-cell 6 Dendritic (B/Mono?) Dendritic cell 7 none Mystery cell 0 T cell CD4 T cell 2,0 T cell CD8 T cell 2,1 NK cell NK cell <p>But what is cluster 7? It has low counts. If it is just ambient 'soup', then we would not expect it to have high levels of cell type specific genes. Let's do differential gene expression analysis to see what is upregulated in this cluster.</p> In\u00a0[121]: Copied! <pre>sc.tl.rank_genes_groups(adNorm, use_raw=False, groupby=\"leiden_R\")\n</pre> sc.tl.rank_genes_groups(adNorm, use_raw=False, groupby=\"leiden_R\") <pre>WARNING: Default of the method has been changed to 't-test' from 't-test_overestim_var'\n</pre> In\u00a0[124]: Copied! <pre>sc.pl.rank_genes_groups_dotplot(adNorm, n_genes=5, groupby=\"leiden_R\", dendrogram=True, key='rank_genes_groups')\n</pre> sc.pl.rank_genes_groups_dotplot(adNorm, n_genes=5, groupby=\"leiden_R\", dendrogram=True, key='rank_genes_groups') In\u00a0[125]: Copied! <pre>sc.pl.rank_genes_groups_dotplot(adNorm, n_genes=20, groupby=\"leiden_R\", dendrogram=True, key='rank_genes_groups', groups=['7'])\n</pre> sc.pl.rank_genes_groups_dotplot(adNorm, n_genes=20, groupby=\"leiden_R\", dendrogram=True, key='rank_genes_groups', groups=['7']) <pre>WARNING: Groups are not reordered because the `groupby` categories and the `var_group_labels` are different.\ncategories: 0, 1, 2,0, etc.\nvar_group_labels: 7\n</pre> <p>Although this result could be refined and explored a lot, it is sufficient for us to address our question about the identity of cluster 7 as follows:</p> Help from ChatGPT to annotate cells <p>Now, let's add the annotation to the anndata.obs and discard the other cells</p> cluster markers  of cell type 1 Monocyte CD14 Monocyte 4,0 Monocyte CD16 Monocyte 3 B B-cell 6 Dendritic (B/Mono?) Dendritic cell 7 none Platelet 0 T cell CD4 T cell 2,0 T cell CD8 T cell 2,1 NK cell NK cell In\u00a0[134]: Copied! <pre>tokeep = [\"1\", \"4,0\", \"3\", \"6\", \"7\", \"0\", \"2,0\", \"2,1\"]\nadNorm2 = adNorm.copy()\nadNorm2 = adNorm2[adNorm2.obs['leiden_R'].isin(tokeep)].copy()\nadNorm2.shape\nadNorm2.obs['leiden_R'].value_counts()\n</pre> tokeep = [\"1\", \"4,0\", \"3\", \"6\", \"7\", \"0\", \"2,0\", \"2,1\"] adNorm2 = adNorm.copy() adNorm2 = adNorm2[adNorm2.obs['leiden_R'].isin(tokeep)].copy() adNorm2.shape adNorm2.obs['leiden_R'].value_counts() Out[134]: <pre>leiden_R\n0      3562\n1      3115\n3      1604\n2,0    1032\n2,1     611\n4,0     368\n6        81\n7        60\nName: count, dtype: int64</pre> In\u00a0[135]: Copied! <pre>cell_dict = {'Dendritic': ['6'],\n             'CD14 Monocyte': ['1'],\n             'CD16 Monocyte': [\"4,0\"],\n             'B cell': ['3'],\n             'Platelet': ['7'],\n             'CD4 T cell': ['0'],\n             'CD8 T cell': [\"2,0\"],\n             'NK cell': [\"2,1\"]\n}\n\nnew_obs_name = 'cell_type'\nadNorm2.obs[new_obs_name] = np.nan\n\nfor i in cell_dict.keys():\n    ind = pd.Series(adNorm2.obs.leiden_R).isin(cell_dict[i])\n    adNorm2.obs.loc[ind,new_obs_name] = i\n\nadNorm2.obs['cell_type'] = adNorm2.obs['cell_type'].astype(\"category\")\n</pre> cell_dict = {'Dendritic': ['6'],              'CD14 Monocyte': ['1'],              'CD16 Monocyte': [\"4,0\"],              'B cell': ['3'],              'Platelet': ['7'],              'CD4 T cell': ['0'],              'CD8 T cell': [\"2,0\"],              'NK cell': [\"2,1\"] }  new_obs_name = 'cell_type' adNorm2.obs[new_obs_name] = np.nan  for i in cell_dict.keys():     ind = pd.Series(adNorm2.obs.leiden_R).isin(cell_dict[i])     adNorm2.obs.loc[ind,new_obs_name] = i  adNorm2.obs['cell_type'] = adNorm2.obs['cell_type'].astype(\"category\")   In\u00a0[136]: Copied! <pre>sc.tl.dendrogram(adNorm2, \"cell_type\")\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12,5), gridspec_kw={'wspace':0.4})\nax1_dict = sc.pl.umap(adNorm2,color=['cell_type'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False)\nax2_dict = sc.pl.dotplot(adNorm2, marker_genes_dict, 'cell_type', dendrogram=True,ax=ax2, show=False)\nplt.show()\n</pre> sc.tl.dendrogram(adNorm2, \"cell_type\") fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12,5), gridspec_kw={'wspace':0.4}) ax1_dict = sc.pl.umap(adNorm2,color=['cell_type'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False) ax2_dict = sc.pl.dotplot(adNorm2, marker_genes_dict, 'cell_type', dendrogram=True,ax=ax2, show=False) plt.show()  <pre>WARNING: Groups are not reordered because the `groupby` categories and the `var_group_labels` are different.\ncategories: B cell, CD14 Monocyte, CD16 Monocyte, etc.\nvar_group_labels: B cell, Dendritic, Monocyte, etc.\n</pre> In\u00a0[137]: Copied! <pre>sc.pl.pca(adNorm2, color=['cell_type', 'GNLY'], alpha=.75, s=15, projection='3d')\n</pre> sc.pl.pca(adNorm2, color=['cell_type', 'GNLY'], alpha=.75, s=15, projection='3d') In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[138]: Copied! <pre>sc.tl.rank_genes_groups(adNorm2, use_raw=False, groupby=\"cell_type\")\n</pre> sc.tl.rank_genes_groups(adNorm2, use_raw=False, groupby=\"cell_type\") <pre>WARNING: Default of the method has been changed to 't-test' from 't-test_overestim_var'\n</pre> In\u00a0[139]: Copied! <pre>sc.tl.filter_rank_genes_groups(adNorm2, min_fold_change=.7, min_in_group_fraction=.5, max_out_group_fraction=.15)\nsc.pl.rank_genes_groups_dotplot(adNorm2, n_genes=6, groupby=\"cell_type\", dendrogram=True, key='rank_genes_groups_filtered')\n</pre> sc.tl.filter_rank_genes_groups(adNorm2, min_fold_change=.7, min_in_group_fraction=.5, max_out_group_fraction=.15) sc.pl.rank_genes_groups_dotplot(adNorm2, n_genes=6, groupby=\"cell_type\", dendrogram=True, key='rank_genes_groups_filtered') In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/L4_scBasics.html#objectives-for-today","title":"Objectives for today\u00b6","text":"<p>At the end of class, students will be familiar with:</p> <ol> <li>How to use Colab to interact with Python interpreter</li> <li>How to transfer files to/from Colab</li> <li>How to install packages on Colab</li> <li>Basics of Scanpy<ol> <li>annData</li> <li>loading and saving files</li> <li>getting var info</li> <li>getting more help: scanpy docs, tutorials, ChatGPT</li> </ol> </li> <li>Quality control</li> <li>Normalization</li> <li>Dimension reduction</li> <li>Cell-cell distance</li> <li>Unsupervised clustering</li> <li>Differential gene expression</li> <li>Cell annotation</li> </ol>"},{"location":"notebooks/L4_scBasics.html#what-we-did-last-time","title":"What we did last time\u00b6","text":"<p>Last time we discussed gene expression, how to measure gene expression in lots of single cells, noted that this is an imperfect surrogate for cell state/identity</p>"},{"location":"notebooks/L4_scBasics.html#outline-for-today","title":"Outline for today\u00b6","text":"<p>Here is what we are going to talk about:</p> <ol> <li>How this is going to work, and what we expect from you, and what you can expect from us</li> <li>Nature of the data: some biological motivation + CellRanger output</li> <li>Intro to Colab/Jupyter</li> <li>How to analyze scRNAseq data</li> <li>Format for HW1 -- What you should turn in, its format</li> </ol>"},{"location":"notebooks/L4_scBasics.html#how-this-will-work","title":"How this will work\u00b6","text":"<p>How this is going to work today. We will break things down into 2-5 minutes bites, where I will tell you about the step, then I'll stop and give you a few minutes to try it on your own. If you would like, please feel free to pair up, at most groups of 3 for this BUT feel no obligation to do so!!! Also, I am not going to ask anyone to show us your work, answer questions, etc. Today is just about getting you hands on experience with these types of analyses so that you are prepared for the first Homework.</p>"},{"location":"notebooks/L4_scBasics.html#background-on-the-data","title":"Background on the data\u00b6","text":"<p>Let's start with some background + motivation for the data set that we are going to analyze: hematopoietic cells from peripheral blood.</p>"},{"location":"notebooks/L4_scBasics.html#hematopoiesis","title":"Hematopoiesis\u00b6","text":"Traditional model of hematopoiesis. Image from Slack 2017 <p>These cells are produced in the bone marrow and then move into the vascular so that they can move about the body and perform their functions (transport oxygen, clot, do adaptive and innate immune things).</p>"},{"location":"notebooks/L4_scBasics.html#peripheral-blood-mononuclear-cells-pbmcs","title":"Peripheral blood mononuclear cells (PBMCs)\u00b6","text":"<p>It is possible to enrich for what are called PBMCs from vein by subjecting sample to density gradient centrifugation. This enrichs for cells that have one, round nucleus, and excludes cells that do not have nuclie, or that have multi-lobed structures. PBMCs typically contain:</p> <p>... several classes of immune cells, including T cells (~70%), B cells (~15%), monocytes (~5%), dendritic cells (~1%) and natural killer (NK) cells (~10%)     --  Sen et al 2019</p> <p>and</p> <p>... The CD3+ lymphocytes are composed of CD4+ and CD8+ T cells, roughly in a 2:1 ratio.     -- Kleiveland, 2015</p>"},{"location":"notebooks/L4_scBasics.html#bio-questions-for-the-day","title":"Bio question(s) for the day\u00b6","text":"<ul> <li>What does scRNAseq estimate as their relative proportion? and how does it compare to the estimate above?</li> <li>To what extent does cell type composition vary between samples?</li> <li>Are there other genes that are better at distinguishing between these populations than marker genes listed below?</li> <li>How many cells do you need to reliably detect a sub-population?</li> </ul>"},{"location":"notebooks/L4_scBasics.html#data","title":"Data\u00b6","text":"<p>10X Genomics scRNA-seq on human PBMCs</p>"},{"location":"notebooks/L4_scBasics.html#sample-1","title":"Sample 1\u00b6","text":"<ul> <li>http://cf.10xgenomics.com/samples/cell-exp/1.1.0/pbmc3k/pbmc3k_filtered_gene_bc_matrices.tar.gz</li> </ul>"},{"location":"notebooks/L4_scBasics.html#sample-2","title":"Sample 2\u00b6","text":"<ul> <li>https://colab.research.google.com/corgiredirector?site=https%3A%2F%2Fcf.10xgenomics.com%2Fsamples%2Fcell-exp%2F6.1.0%2F20k_PBMC_3p_HT_nextgem_Chromium_X%2F20k_PBMC_3p_HT_nextgem_Chromium_X_filtered_feature_bc_matrix.h5</li> <li>20k Human PBMCs, 3\u2019 HT v3.1, Chromium X</li> <li>Sourced from a healthy female donor</li> <li>23,837 cells</li> <li>35,000 reads per cell</li> <li>Filtered data in .h5 format</li> </ul>"},{"location":"notebooks/L4_scBasics.html#cellranger","title":"CellRanger\u00b6","text":"<p>CellRanger is the program that converts sequencing reads into gene expression counts.</p> CellRanger flow chart from 10X genomics"},{"location":"notebooks/L4_scBasics.html#jupyter-basics","title":"Jupyter basics\u00b6","text":"<p>Connect to Colab: https://colab.research.google.com/</p>"},{"location":"notebooks/L4_scBasics.html#install-scanpy","title":"Install scanpy\u00b6","text":""},{"location":"notebooks/L4_scBasics.html#fetch-data-files","title":"Fetch data file(s)\u00b6","text":""},{"location":"notebooks/L4_scBasics.html#scanpy-basics","title":"Scanpy basics\u00b6","text":""},{"location":"notebooks/L4_scBasics.html#load-packages","title":"load packages\u00b6","text":""},{"location":"notebooks/L4_scBasics.html#load-sample-1","title":"Load Sample 1\u00b6","text":""},{"location":"notebooks/L4_scBasics.html#getting-information-about-functions","title":"Getting information about functions\u00b6","text":"<p>You can get info about functions using</p> <p>help(functionName)</p> <p>or</p> <p>?functionName</p>"},{"location":"notebooks/L4_scBasics.html#inspecting-the-data-gross-properties","title":"Inspecting the data -- gross properties\u00b6","text":""},{"location":"notebooks/L4_scBasics.html#anndata","title":"AnnData\u00b6","text":"<p>AnnData is a Python package that defines a data structure designed to efficiently store large data sets like scRNA-seq.</p> AnnData schema. See Resouces below for link to documentation"},{"location":"notebooks/L4_scBasics.html#slicing-or-subsetting","title":"Slicing or subsetting\u00b6","text":"<p>Get a small subset of the data</p>"},{"location":"notebooks/L4_scBasics.html#gene-counts","title":"Gene counts\u00b6","text":"<p>So, where is the data?</p>"},{"location":"notebooks/L4_scBasics.html#meta-data","title":"meta data\u00b6","text":"<p>for cells, see .obs</p> <p>for genesm see .var</p>"},{"location":"notebooks/L4_scBasics.html#loc","title":".loc\u00b6","text":"<p>Use .loc function to index based with labels</p>"},{"location":"notebooks/L4_scBasics.html#quality-control-qc","title":"Quality Control (QC)\u00b6","text":"<p>We want to find putative doublets and low quality cell barcodes and exclude them. We also can remove genes that are not detected in vast majority of cells. pp.calculate_qc_metrics() will calcualte a set of metrics for both obs and var that can be used for QC filtering. It can also take inputs to specify other, custom metrics to compute. Below, we use it to compute the fraction total umis in each cell that are mitochondrially encoded or that code for ribosomal genes.</p>"},{"location":"notebooks/L4_scBasics.html#visualize","title":"Visualize\u00b6","text":"<p>Take a look some typical QC values across these data</p>"},{"location":"notebooks/L4_scBasics.html#normalization","title":"Normalization\u00b6","text":"<p>Simple library size scaling, then log transform. There are many other ways to do correct for cell-to-cell technical variation, for example different cell lysis efficiencies, but this method is good enough.</p>"},{"location":"notebooks/L4_scBasics.html#highly-variable-genes-hvg","title":"Highly variable genes (HVG)\u00b6","text":"<p>It is common practice to limit some parts of analysis to those variables/genes that exhibit some degree of variation in their values across the data. We call these highly variable genes, or HVG for short. To find these, calculate some gene statistics, which when combined with thresholds below, determine which genes are considered HVG. These metrics are mean expression and dispersion (variance / mean). Variance is defined as the expected squared deviation of gene expression. The normalized dispersion is calculated by scaling based on a bin of mean expression.</p>"},{"location":"notebooks/L4_scBasics.html#pca","title":"PCA\u00b6","text":"<p>There are two facts that make PCA a good tool for analzying scRNAseq data: 1.) genes are expressed in coordinated fashion, meaning that many have correlated expression patterns. 2.) Second scRNAseq data is noisy.</p> <p>PCA allows us to reduce a high dimensional data set into a lower dimension in which much of the total variation is maintained. To understand PCA, you need to know linear algebra. In essence, it identifies sets of linear combinations of genes in such a way that they uncorrelated and explain most variation in the data. The function call does the following:</p> <ul> <li>compute the covariance matrix (correlation between each pair of genes)</li> <li>finding eigenvectors (directions of axes that maximize that variance), orthogonal to each other</li> </ul> <p>Later, we find select a number num_pcs as the number of PCs that contribute most to the total variation on our data. We use these PCs to compute cell-to-cell distances for embedding and for clustering of cells.</p>"},{"location":"notebooks/L4_scBasics.html#marker-genes","title":"Marker genes\u00b6","text":"<p>Here PBMC cell types and some genes that have been used to identify them: Monocytes: CD14, CD68, LYZ Dendritic: CLEC4C, FLT3 NK cells: GNLY, NCAM1 B cells: CD19, CD79A, CD79B T cells: CD3D, CD3E, TRAC, TRBC</p>"},{"location":"notebooks/L4_scBasics.html#pca-loadings","title":"PCA Loadings\u00b6","text":"<p>Where are PCs (i.e. loadings -- the contribution of each gene to each PC) stored in anndata? .varm (see figure of anndata way above)?</p>"},{"location":"notebooks/L4_scBasics.html#knn-cell-cell-distances","title":"kNN cell-cell distances\u00b6","text":"<p>The k-nearest neighbor graph generates an adjacency matrix by finding, for each cell, the k cells that are closest to it. This helps to reduce noise in computing cell-cell distances or similarities and is important for embedding the cells in a 2D space, and for community detection algorithms. Two arguments are n_neighbors, or k, and the number of PCs to use when computing cell-cell distances.</p>"},{"location":"notebooks/L4_scBasics.html#visualization-of-cell-cell-similarities","title":"Visualization of cell-cell similarities\u00b6","text":""},{"location":"notebooks/L4_scBasics.html#umap-embedding","title":"UMAP embedding\u00b6","text":"<p>This an elaboration on the t-SNE embedding approach. Both of these methods try to project cells into a reduced (typically 2) dimensional coordinate system while maintaining both the global and local structure of the high dimensional space of the data (i.e. cells that are distant from each other high dimensions should still be distant in the reduced embedding; same is true for cells that are near each other). The distances come from the kNN graph.</p>"},{"location":"notebooks/L4_scBasics.html#unsupervised-clustering","title":"Unsupervised clustering\u00b6","text":"<p>Let's try to assign cells to distinct groups or clusters based on the cell-to-cell distances. Leiden and Louvain are examples of community detection methods that perform this task by searching for the group assignment that maximize within group similarity (which is equivalent to within group edges of a knn graph) and to minimize between group similarity.</p>"},{"location":"notebooks/L4_scBasics.html#cluster-annotation","title":"Cluster annotation\u00b6","text":"<p>We can walk down the rows of the dotplot and guess at the cell types of some of these clusters based on the specificty of marker expression:</p> cluster markers  of cell type 5 B, Dendritic, Mono ??? 1 Monocyte Monocyte 4 Monocyte, T ??? 3 B B-cell 6 Dendritic (B/Mono?) Dendritic cell 7 none Mystery cell 0 T cell T cell 2 NK/T ??? <p>Some clusters are ambiguous because they express markers of more than one cell type. This could be due to the cluster containing &gt; 1 cell type, or because the cell barcodes are doublets. If the former, then we should be able to sub cluster them. Let's try this.</p> <p>Clusters to refine are 5, 4, and 2.</p>"},{"location":"notebooks/L4_scBasics.html#differential-gene-expression","title":"Differential gene expression\u00b6","text":""},{"location":"notebooks/L4_scBasics.html#differential-expression-analysis","title":"Differential expression analysis\u00b6","text":"<p>Let's identify genes that are preferenntially expressed in each cluster versus all the others as a final step to annotate these clusters and to remove ones that are likely to be doublets.</p>"},{"location":"notebooks/L4_scBasics.html#dot-plot-of-differentially-expressed-genes","title":"Dot plot of differentially expressed genes\u00b6","text":"<p>First, we will apply a filter so that we only display genes that meet additional criteria beyond statistical: fold change, % expressed in cluster, % expressed in other cells</p>"},{"location":"notebooks/L4_scBasics.html#resources","title":"Resources\u00b6","text":""},{"location":"notebooks/L4_scBasics.html#tools","title":"Tools\u00b6","text":"<ul> <li>Colab<ul> <li>https://colab.research.google.com/</li> </ul> </li> <li>Jupyter<ul> <li>https://jupyter.org/</li> </ul> </li> <li>CellRanger<ul> <li>https://www.10xgenomics.com/support/software/cell-ranger/latest/advanced/cr-barcode-rank-plot</li> <li>https://www.10xgenomics.com/support/software/cell-ranger/latest/algorithms-overview/cr-gex-algorithm</li> </ul> </li> </ul>"},{"location":"notebooks/L4_scBasics.html#literature","title":"Literature\u00b6","text":"<ul> <li>Best practices<ul> <li>best practices in sc analysis online book</li> <li>paper associated with the above online book</li> </ul> </li> <li>Scanpy<ul> <li>https://scanpy.readthedocs.io/en/stable/</li> <li>https://scanpy.readthedocs.io/en/stable/tutorials.html</li> <li>https://scanpy-tutorials.readthedocs.io/en/latest/pbmc3k.html</li> <li>https://scanpy-tutorials.readthedocs.io/en/latest/plotting/advanced.html</li> <li>https://scanpy-tutorials.readthedocs.io/en/latest/plotting/core.html</li> </ul> </li> <li>AnnData<ul> <li>https://anndata.readthedocs.io/en/latest/tutorials/notebooks/getting-started.html</li> <li>https://anndata.readthedocs.io/en/latest/index.html</li> </ul> </li> <li>QC<ul> <li>https://genomebiology.biomedcentral.com/articles/10.1186/s13059-020-02136-7</li> </ul> </li> </ul>"},{"location":"notebooks/L4_scBasics_v2.html","title":"L4 scBasics v2","text":"Fundamentals of scRNA-seq analysis in Python Lecture 4, 02-01-2024 This notebook is part the course 580.447/647 Computational Stem Cell Biology taught by Patrick Cahan at Johns Hopkins University in Winter/Spring 2024. Many parts of this tutorial are derived from the sources listed in the Resources section at the end of this notebook. <p>Here is a more detailed glimpse of what is happening here:</p> CellRanger flow chart 2 from 10X genomics CellRanger mapping from 10X genomics In\u00a0[\u00a0]: Copied! <pre>!pip install scanpy scipy umap-learn leidenalg\n</pre> !pip install scanpy scipy umap-learn leidenalg In\u00a0[\u00a0]: Copied! <pre># wget for linux/unix\n# !wget https://cf.10xgenomics.com/samples/cell-exp/3.0.0/pbmc_10k_v3/pbmc_10k_v3_filtered_feature_bc_matrix.h5\n# !wget https://cf.10xgenomics.com/samples/cell-exp/6.1.0/20k_PBMC_3p_HT_nextgem_Chromium_X/20k_PBMC_3p_HT_nextgem_Chromium_X_filtered_feature_bc_matrix.h5\n\n# curl for macOS; i have no clue what to use for Windows\n!curl https://cf.10xgenomics.com/samples/cell-exp/3.0.0/pbmc_10k_v3/pbmc_10k_v3_filtered_feature_bc_matrix.h5 -o pbmc_10k_v3_filtered_feature_bc_matrix.h5\n!curl https://cf.10xgenomics.com/samples/cell-exp/6.1.0/20k_PBMC_3p_HT_nextgem_Chromium_X/20k_PBMC_3p_HT_nextgem_Chromium_X_filtered_feature_bc_matrix.h5 -o 20k_PBMC_3p_HT_nextgem_Chromium_X_filtered_feature_bc_matrix.h5\n</pre> # wget for linux/unix # !wget https://cf.10xgenomics.com/samples/cell-exp/3.0.0/pbmc_10k_v3/pbmc_10k_v3_filtered_feature_bc_matrix.h5 # !wget https://cf.10xgenomics.com/samples/cell-exp/6.1.0/20k_PBMC_3p_HT_nextgem_Chromium_X/20k_PBMC_3p_HT_nextgem_Chromium_X_filtered_feature_bc_matrix.h5  # curl for macOS; i have no clue what to use for Windows !curl https://cf.10xgenomics.com/samples/cell-exp/3.0.0/pbmc_10k_v3/pbmc_10k_v3_filtered_feature_bc_matrix.h5 -o pbmc_10k_v3_filtered_feature_bc_matrix.h5 !curl https://cf.10xgenomics.com/samples/cell-exp/6.1.0/20k_PBMC_3p_HT_nextgem_Chromium_X/20k_PBMC_3p_HT_nextgem_Chromium_X_filtered_feature_bc_matrix.h5 -o 20k_PBMC_3p_HT_nextgem_Chromium_X_filtered_feature_bc_matrix.h5 In\u00a0[3]: Copied! <pre>import scanpy as sc\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport warnings\nwarnings.filterwarnings('ignore')\nplt.rcParams['figure.dpi'] = 300\nsc.logging.print_header()\n</pre> import scanpy as sc import numpy as np import pandas as pd import matplotlib.pyplot as plt import warnings warnings.filterwarnings('ignore') plt.rcParams['figure.dpi'] = 300 sc.logging.print_header() <pre>scanpy==1.9.8 anndata==0.10.5.post1 umap==0.5.5 numpy==1.26.3 scipy==1.12.0 pandas==2.2.0 scikit-learn==1.4.0 statsmodels==0.14.1 igraph==0.11.3 pynndescent==0.5.11\n</pre> In\u00a0[4]: Copied! <pre># I have stored these data files in the directory data/ \nad10f = sc.read_10x_h5(\"data/pbmc_10k_v3_filtered_feature_bc_matrix.h5\")\n# If you stored yours in the cwd on Colab, you should uncomment and run this line instead to load your data:\n# ad10f = sc.read_10x_h5(\"pbmc_10k_v3_filtered_feature_bc_matrix.h5\")\n</pre> # I have stored these data files in the directory data/  ad10f = sc.read_10x_h5(\"data/pbmc_10k_v3_filtered_feature_bc_matrix.h5\") # If you stored yours in the cwd on Colab, you should uncomment and run this line instead to load your data: # ad10f = sc.read_10x_h5(\"pbmc_10k_v3_filtered_feature_bc_matrix.h5\") In\u00a0[5]: Copied! <pre>?sc.read_10x_h5\n</pre> ?sc.read_10x_h5 <pre>Signature:\nsc.read_10x_h5(\n    filename: 'Union[str, Path]',\n    genome: 'Optional[str]' = None,\n    gex_only: 'bool' = True,\n    backup_url: 'Optional[str]' = None,\n) -&gt; 'AnnData'\nDocstring:\nRead 10x-Genomics-formatted hdf5 file.\n\nParameters\n----------\nfilename : 'Union[str, Path]'\n    Path to a 10x hdf5 file.\ngenome : 'Optional[str]', optional (default: None)\n    Filter expression to genes within this genome. For legacy 10x h5\n    files, this must be provided if the data contains more than one genome.\ngex_only : 'bool', optional (default: True)\n    Only keep 'Gene Expression' data and ignore other feature types,\n    e.g. 'Antibody Capture', 'CRISPR Guide Capture', or 'Custom'\nbackup_url : 'Optional[str]', optional (default: None)\n    Retrieve the file from an URL if not present on disk.\n\nReturns\n-------\nAnnotated data matrix, where observations/cells are named by their\nbarcode and variables/genes by gene name. Stores the following information:\n\n:attr:`~anndata.AnnData.X`\n    The data matrix is stored\n:attr:`~anndata.AnnData.obs_names`\n    Cell names\n:attr:`~anndata.AnnData.var_names`\n    Gene names\n:attr:`~anndata.AnnData.var`\\ `['gene_ids']`\n    Gene IDs\n:attr:`~anndata.AnnData.var`\\ `['feature_types']`\n    Feature types\nFile:      /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs_material/lib/python3.12/site-packages/scanpy/readwrite.py\nType:      function</pre> In\u00a0[6]: Copied! <pre>print(ad10f)\n</pre> print(ad10f) <pre>AnnData object with n_obs \u00d7 n_vars = 11769 \u00d7 33538\n    var: 'gene_ids', 'feature_types', 'genome'\n</pre> In\u00a0[7]: Copied! <pre>ad10f.shape\n</pre> ad10f.shape Out[7]: <pre>(11769, 33538)</pre> In\u00a0[8]: Copied! <pre>type(ad10f)\n</pre> type(ad10f) Out[8]: <pre>anndata._core.anndata.AnnData</pre> In\u00a0[9]: Copied! <pre>ncells = 3\nngenes = 4\nrandGenes = np.random.choice(ad10f.var_names, size=ngenes, replace=False)\nrandCells = np.random.choice(ad10f.obs_names, size=ncells, replace=False)\n</pre> ncells = 3 ngenes = 4 randGenes = np.random.choice(ad10f.var_names, size=ngenes, replace=False) randCells = np.random.choice(ad10f.obs_names, size=ncells, replace=False) In\u00a0[10]: Copied! <pre>print(randCells)\n</pre> print(randCells) <pre>['CAGCAATGTGAGATCG-1' 'TCCGAAATCGAGTTGT-1' 'CACGGGTCACCAGGTC-1']\n</pre> In\u00a0[11]: Copied! <pre>print(randGenes)\n</pre> print(randGenes) <pre>['FADS6' 'NLRP13' 'KRTAP2-1' 'SSTR5']\n</pre> In\u00a0[12]: Copied! <pre>newAnndata = ad10f[ randCells ]\nnewAnndata\n</pre> newAnndata = ad10f[ randCells ] newAnndata Out[12]: <pre>View of AnnData object with n_obs \u00d7 n_vars = 3 \u00d7 33538\n    var: 'gene_ids', 'feature_types', 'genome'</pre> In\u00a0[13]: Copied! <pre>ad10f[ randGenes ]\n</pre> ad10f[ randGenes ] <pre>\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nCell In[13], line 1\n----&gt; 1 ad10f[ randGenes ]\n\nFile /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs_material/lib/python3.12/site-packages/anndata/_core/anndata.py:1177, in AnnData.__getitem__(self, index)\n   1175 def __getitem__(self, index: Index) -&gt; AnnData:\n   1176     \"\"\"Returns a sliced view of the object.\"\"\"\n-&gt; 1177     oidx, vidx = self._normalize_indices(index)\n   1178     return AnnData(self, oidx=oidx, vidx=vidx, asview=True)\n\nFile /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs_material/lib/python3.12/site-packages/anndata/_core/anndata.py:1158, in AnnData._normalize_indices(self, index)\n   1157 def _normalize_indices(self, index: Index | None) -&gt; tuple[slice, slice]:\n-&gt; 1158     return _normalize_indices(index, self.obs_names, self.var_names)\n\nFile /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs_material/lib/python3.12/site-packages/anndata/_core/index.py:35, in _normalize_indices(index, names0, names1)\n     33         index = index[0].values, index[1]\n     34 ax0, ax1 = unpack_index(index)\n---&gt; 35 ax0 = _normalize_index(ax0, names0)\n     36 ax1 = _normalize_index(ax1, names1)\n     37 return ax0, ax1\n\nFile /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs_material/lib/python3.12/site-packages/anndata/_core/index.py:101, in _normalize_index(indexer, index)\n     99         if np.any(positions &lt; 0):\n    100             not_found = indexer[positions &lt; 0]\n--&gt; 101             raise KeyError(\n    102                 f\"Values {list(not_found)}, from {list(indexer)}, \"\n    103                 \"are not valid obs/ var names or indices.\"\n    104             )\n    105         return positions  # np.ndarray[int]\n    106 else:\n\nKeyError: \"Values ['FADS6', 'NLRP13', 'KRTAP2-1', 'SSTR5'], from ['FADS6', 'NLRP13', 'KRTAP2-1', 'SSTR5'], are not valid obs/ var names or indices.\"</pre> In\u00a0[14]: Copied! <pre>ad10f[:, randGenes ]\n</pre> ad10f[:, randGenes ] <pre>\n---------------------------------------------------------------------------\nInvalidIndexError                         Traceback (most recent call last)\nCell In[14], line 1\n----&gt; 1 ad10f[:, randGenes ]\n\nFile /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs_material/lib/python3.12/site-packages/anndata/_core/anndata.py:1177, in AnnData.__getitem__(self, index)\n   1175 def __getitem__(self, index: Index) -&gt; AnnData:\n   1176     \"\"\"Returns a sliced view of the object.\"\"\"\n-&gt; 1177     oidx, vidx = self._normalize_indices(index)\n   1178     return AnnData(self, oidx=oidx, vidx=vidx, asview=True)\n\nFile /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs_material/lib/python3.12/site-packages/anndata/_core/anndata.py:1158, in AnnData._normalize_indices(self, index)\n   1157 def _normalize_indices(self, index: Index | None) -&gt; tuple[slice, slice]:\n-&gt; 1158     return _normalize_indices(index, self.obs_names, self.var_names)\n\nFile /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs_material/lib/python3.12/site-packages/anndata/_core/index.py:36, in _normalize_indices(index, names0, names1)\n     34 ax0, ax1 = unpack_index(index)\n     35 ax0 = _normalize_index(ax0, names0)\n---&gt; 36 ax1 = _normalize_index(ax1, names1)\n     37 return ax0, ax1\n\nFile /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs_material/lib/python3.12/site-packages/anndata/_core/index.py:98, in _normalize_index(indexer, index)\n     96     return positions  # np.ndarray[int]\n     97 else:  # indexer should be string array\n---&gt; 98     positions = index.get_indexer(indexer)\n     99     if np.any(positions &lt; 0):\n    100         not_found = indexer[positions &lt; 0]\n\nFile /opt/homebrew/Caskroom/miniforge/base/envs/mkdocs_material/lib/python3.12/site-packages/pandas/core/indexes/base.py:3882, in Index.get_indexer(self, target, method, limit, tolerance)\n   3879 self._check_indexing_method(method, limit, tolerance)\n   3881 if not self._index_as_unique:\n-&gt; 3882     raise InvalidIndexError(self._requires_unique_msg)\n   3884 if len(target) == 0:\n   3885     return np.array([], dtype=np.intp)\n\nInvalidIndexError: Reindexing only valid with uniquely valued Index objects</pre> In\u00a0[15]: Copied! <pre>gname_counts = ad10f.var_names.value_counts()\nnp.any(gname_counts&gt;1)\n</pre> gname_counts = ad10f.var_names.value_counts() np.any(gname_counts&gt;1) Out[15]: <pre>True</pre> In\u00a0[16]: Copied! <pre>duplicates = gname_counts[gname_counts &gt; 1]\nprint(duplicates)\n</pre> duplicates = gname_counts[gname_counts &gt; 1] print(duplicates) <pre>PDE11A       2\nSCO2         2\nLINC01505    2\nPRSS50       2\nATXN7        2\nEMG1         2\nCYB561D2     2\nLINC01238    2\nCCDC39       2\nTXNRD3NB     2\nABCF2        2\nHSPA14       2\nTBCE         2\nSOD2         2\nRGS5         2\nTMSB15B      2\nMATR3        2\nPINX1        2\nPOLR2J3      2\nDIABLO       2\nLINC02203    2\nIGF2         2\nH2BFS        2\nCOG8         2\nName: count, dtype: int64\n</pre> In\u00a0[17]: Copied! <pre>ad10f.var_names_make_unique()\nad10f[:, randGenes ]\n</pre> ad10f.var_names_make_unique() ad10f[:, randGenes ] Out[17]: <pre>View of AnnData object with n_obs \u00d7 n_vars = 11769 \u00d7 4\n    var: 'gene_ids', 'feature_types', 'genome'</pre> In\u00a0[18]: Copied! <pre>ad10f[randCells, randGenes ]\n</pre> ad10f[randCells, randGenes ] Out[18]: <pre>View of AnnData object with n_obs \u00d7 n_vars = 3 \u00d7 4\n    var: 'gene_ids', 'feature_types', 'genome'</pre> Views Views are pointers to memory where original anndata is stored. They are _not_ copies of the variable.   In\u00a0[19]: Copied! <pre>ad10f[randCells, randGenes ].X\n</pre> ad10f[randCells, randGenes ].X Out[19]: <pre>&lt;3x4 sparse matrix of type '&lt;class 'numpy.float32'&gt;'\n\twith 0 stored elements in Compressed Sparse Row format&gt;</pre> In\u00a0[20]: Copied! <pre>print(ad10f.obs.columns)\n</pre> print(ad10f.obs.columns) <pre>Index([], dtype='object')\n</pre> In\u00a0[21]: Copied! <pre>ad10f.obs['sample_name'] = \"sample_1\"\nprint(ad10f.obs.columns)\n</pre> ad10f.obs['sample_name'] = \"sample_1\" print(ad10f.obs.columns) <pre>Index(['sample_name'], dtype='object')\n</pre> In\u00a0[22]: Copied! <pre>print(ad10f[randCells].obs)\n</pre> print(ad10f[randCells].obs) <pre>                   sample_name\nCAGCAATGTGAGATCG-1    sample_1\nTCCGAAATCGAGTTGT-1    sample_1\nCACGGGTCACCAGGTC-1    sample_1\n</pre> In\u00a0[23]: Copied! <pre>print(ad10f.var.columns)\n</pre> print(ad10f.var.columns) <pre>Index(['gene_ids', 'feature_types', 'genome'], dtype='object')\n</pre> In\u00a0[24]: Copied! <pre>print(ad10f[:,randGenes].var)\n</pre> print(ad10f[:,randGenes].var) <pre>                 gene_ids    feature_types  genome\nFADS6     ENSG00000172782  Gene Expression  GRCh38\nNLRP13    ENSG00000173572  Gene Expression  GRCh38\nKRTAP2-1  ENSG00000212725  Gene Expression  GRCh38\nSSTR5     ENSG00000162009  Gene Expression  GRCh38\n</pre> In\u00a0[23]: Copied! <pre>print(ad10f.var[randGenes,:])\n</pre> print(ad10f.var[randGenes,:]) <pre>\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nFile /opt/homebrew/Caskroom/miniforge/base/envs/pyscn_v3/lib/python3.11/site-packages/pandas/core/indexes/base.py:3790, in Index.get_loc(self, key)\n   3789 try:\n-&gt; 3790     return self._engine.get_loc(casted_key)\n   3791 except KeyError as err:\n\nFile index.pyx:152, in pandas._libs.index.IndexEngine.get_loc()\n\nFile index.pyx:158, in pandas._libs.index.IndexEngine.get_loc()\n\nTypeError: '(array(['PREP', 'AL589986.1', 'AC245140.3', 'AL445228.1'], dtype=object), slice(None, None, None))' is an invalid key\n\nDuring handling of the above exception, another exception occurred:\n\nInvalidIndexError                         Traceback (most recent call last)\nCell In[23], line 1\n----&gt; 1 print(ad10f.var[randGenes,:])\n\nFile /opt/homebrew/Caskroom/miniforge/base/envs/pyscn_v3/lib/python3.11/site-packages/pandas/core/frame.py:3896, in DataFrame.__getitem__(self, key)\n   3894 if self.columns.nlevels &gt; 1:\n   3895     return self._getitem_multilevel(key)\n-&gt; 3896 indexer = self.columns.get_loc(key)\n   3897 if is_integer(indexer):\n   3898     indexer = [indexer]\n\nFile /opt/homebrew/Caskroom/miniforge/base/envs/pyscn_v3/lib/python3.11/site-packages/pandas/core/indexes/base.py:3802, in Index.get_loc(self, key)\n   3797     raise KeyError(key) from err\n   3798 except TypeError:\n   3799     # If we have a listlike key, _check_indexing_error will raise\n   3800     #  InvalidIndexError. Otherwise we fall through and re-raise\n   3801     #  the TypeError.\n-&gt; 3802     self._check_indexing_error(key)\n   3803     raise\n\nFile /opt/homebrew/Caskroom/miniforge/base/envs/pyscn_v3/lib/python3.11/site-packages/pandas/core/indexes/base.py:5974, in Index._check_indexing_error(self, key)\n   5970 def _check_indexing_error(self, key):\n   5971     if not is_scalar(key):\n   5972         # if key is not a scalar, directly raise an error (the code below\n   5973         # would convert to numpy arrays and raise later any way) - GH29926\n-&gt; 5974         raise InvalidIndexError(key)\n\nInvalidIndexError: (array(['PREP', 'AL589986.1', 'AC245140.3', 'AL445228.1'], dtype=object), slice(None, None, None))</pre> In\u00a0[25]: Copied! <pre>print(ad10f.var.loc[randGenes])\n</pre> print(ad10f.var.loc[randGenes]) <pre>                 gene_ids    feature_types  genome\nFADS6     ENSG00000172782  Gene Expression  GRCh38\nNLRP13    ENSG00000173572  Gene Expression  GRCh38\nKRTAP2-1  ENSG00000212725  Gene Expression  GRCh38\nSSTR5     ENSG00000162009  Gene Expression  GRCh38\n</pre> In\u00a0[26]: Copied! <pre>ad10f.var['mt'] = ad10f.var_names.str.startswith('MT-')\nribo_prefix = (\"RPS\",\"RPL\")\nad10f.var['ribo'] = ad10f.var_names.str.startswith(ribo_prefix)\nsc.pp.calculate_qc_metrics(ad10f, qc_vars=['mt','ribo'], percent_top=None, log1p=False, inplace=True)\n</pre> ad10f.var['mt'] = ad10f.var_names.str.startswith('MT-') ribo_prefix = (\"RPS\",\"RPL\") ad10f.var['ribo'] = ad10f.var_names.str.startswith(ribo_prefix) sc.pp.calculate_qc_metrics(ad10f, qc_vars=['mt','ribo'], percent_top=None, log1p=False, inplace=True) In\u00a0[27]: Copied! <pre>adClean = ad10f.copy()\n\nfig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(10,4), gridspec_kw={'wspace':0.25}, constrained_layout=True)\nax1_dict = sc.pl.scatter(adClean, x='total_counts', y='pct_counts_mt', ax=ax1, show=False)\nax2_dict = sc.pl.scatter(adClean, x='total_counts', y='n_genes_by_counts',ax=ax2, show=False)\nax3_dict = sc.pl.scatter(adClean, x='pct_counts_ribo', y='n_genes_by_counts',ax=ax3, show=False)\nplt.show()\n</pre> adClean = ad10f.copy()  fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(10,4), gridspec_kw={'wspace':0.25}, constrained_layout=True) ax1_dict = sc.pl.scatter(adClean, x='total_counts', y='pct_counts_mt', ax=ax1, show=False) ax2_dict = sc.pl.scatter(adClean, x='total_counts', y='n_genes_by_counts',ax=ax2, show=False) ax3_dict = sc.pl.scatter(adClean, x='pct_counts_ribo', y='n_genes_by_counts',ax=ax3, show=False) plt.show() <p>Now, do the filtering. First, keep only cells with &lt; 20% mitochonrially encoded gene total UMIs</p> In\u00a0[28]: Copied! <pre>adClean = adClean[adClean.obs['pct_counts_mt']&lt;20,:].copy()\nadClean.n_obs\n</pre> adClean = adClean[adClean.obs['pct_counts_mt']&lt;20,:].copy() adClean.n_obs Out[28]: <pre>11047</pre> <p>Now filter based on total number of genes detected (at least 500) and total number of counts (less than 30,000). And keep genes that are detected in at least 3 cells.</p> In\u00a0[29]: Copied! <pre>sc.pp.filter_cells(adClean, min_genes=500)\nsc.pp.filter_cells(adClean, max_counts=30000)\nsc.pp.filter_genes(adClean, min_cells=3)\nadClean.shape\n</pre> sc.pp.filter_cells(adClean, min_genes=500) sc.pp.filter_cells(adClean, max_counts=30000) sc.pp.filter_genes(adClean, min_cells=3) adClean.shape Out[29]: <pre>(10891, 20181)</pre> In\u00a0[83]: Copied! <pre>adNorm = adClean.copy()\nsc.pp.normalize_total(adNorm , target_sum=1e4)\nsc.pp.log1p(adNorm )\n</pre> adNorm = adClean.copy() sc.pp.normalize_total(adNorm , target_sum=1e4) sc.pp.log1p(adNorm ) In\u00a0[84]: Copied! <pre>sc.pp.highly_variable_genes(adNorm , min_mean=0.0125, max_mean=6, min_disp=0.25)\nadNorm.var\n</pre> sc.pp.highly_variable_genes(adNorm , min_mean=0.0125, max_mean=6, min_disp=0.25) adNorm.var Out[84]: gene_ids feature_types genome mt ribo n_cells_by_counts mean_counts pct_dropout_by_counts total_counts n_cells highly_variable means dispersions dispersions_norm AL627309.1 ENSG00000238009 Gene Expression GRCh38 False False 60 0.005183 99.490186 61.0 60 False 0.007519 0.595591 -0.001919 AL627309.3 ENSG00000239945 Gene Expression GRCh38 False False 4 0.000340 99.966012 4.0 4 False 0.000389 0.144284 -1.366927 AL669831.5 ENSG00000237491 Gene Expression GRCh38 False False 679 0.062367 94.230606 734.0 665 False 0.077585 0.586329 -0.029932 FAM87B ENSG00000177757 Gene Expression GRCh38 False False 13 0.001190 99.889540 14.0 13 False 0.001139 0.169543 -1.290532 LINC00115 ENSG00000225880 Gene Expression GRCh38 False False 350 0.031269 97.026085 368.0 337 False 0.038579 0.459107 -0.414723 ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... AC011043.1 ENSG00000276256 Gene Expression GRCh38 False False 77 0.006882 99.345739 81.0 74 False 0.010262 0.738345 0.429851 AL592183.1 ENSG00000273748 Gene Expression GRCh38 False False 32 0.002719 99.728099 32.0 30 False 0.003977 0.799225 0.613985 AC007325.4 ENSG00000278817 Gene Expression GRCh38 False False 239 0.020902 97.969241 246.0 233 False 0.023936 0.329110 -0.807909 AL354822.1 ENSG00000278384 Gene Expression GRCh38 False False 319 0.028210 97.289489 332.0 303 False 0.038089 0.594378 -0.005588 AC240274.1 ENSG00000271254 Gene Expression GRCh38 False False 101 0.008752 99.141813 103.0 99 False 0.010213 0.301150 -0.892475 <p>20181 rows \u00d7 14 columns</p> In\u00a0[85]: Copied! <pre>sc.pl.highly_variable_genes(adNorm)\n</pre> sc.pl.highly_variable_genes(adNorm) In\u00a0[86]: Copied! <pre>sc.tl.pca(adNorm , use_highly_variable=True)\n</pre> sc.tl.pca(adNorm , use_highly_variable=True) In\u00a0[87]: Copied! <pre>markerGenes = ['CD14','CLEC4C', 'CD19',  'GNLY', 'CD3D']\nsc.pl.pca(adNorm , color=markerGenes, ncols=2)\n</pre> markerGenes = ['CD14','CLEC4C', 'CD19',  'GNLY', 'CD3D'] sc.pl.pca(adNorm , color=markerGenes, ncols=2) In\u00a0[35]: Copied! <pre>sc.pl.pca(adNorm, color=['total_counts', 'pct_counts_mt', 'pct_counts_ribo'], s=25,ncols=3)\n</pre> sc.pl.pca(adNorm, color=['total_counts', 'pct_counts_mt', 'pct_counts_ribo'], s=25,ncols=3) In\u00a0[36]: Copied! <pre>sc.pl.pca_variance_ratio(adNorm, 50)\n</pre> sc.pl.pca_variance_ratio(adNorm, 50) In\u00a0[88]: Copied! <pre>np.shape(adNorm.varm[\"PCs\"])\n</pre> np.shape(adNorm.varm[\"PCs\"]) Out[88]: <pre>(20181, 50)</pre> <p>Where are the PC values of each cell (i.e. the PC scores) stored in anndata? .obsm</p> In\u00a0[89]: Copied! <pre>np.shape(adNorm.obsm[\"X_pca\"])\n</pre> np.shape(adNorm.obsm[\"X_pca\"]) Out[89]: <pre>(10891, 50)</pre> In\u00a0[90]: Copied! <pre>n_neighbors = 20\nn_pcs = 10\nsc.pp.neighbors(adNorm, n_neighbors=n_neighbors, n_pcs=n_pcs)\n</pre> n_neighbors = 20 n_pcs = 10 sc.pp.neighbors(adNorm, n_neighbors=n_neighbors, n_pcs=n_pcs) In\u00a0[91]: Copied! <pre>sc.tl.umap(adNorm, 0.25)\n</pre> sc.tl.umap(adNorm, 0.25) In\u00a0[92]: Copied! <pre>sc.pl.umap(adNorm, color=markerGenes, alpha=.75, s=15, ncols=2)\n</pre> sc.pl.umap(adNorm, color=markerGenes, alpha=.75, s=15, ncols=2) In\u00a0[93]: Copied! <pre>sc.tl.leiden(adNorm,.1)\n</pre> sc.tl.leiden(adNorm,.1) In\u00a0[94]: Copied! <pre>sc.pl.umap(adNorm,color=['leiden'], alpha=.75, s=15, legend_loc='on data')\n</pre> sc.pl.umap(adNorm,color=['leiden'], alpha=.75, s=15, legend_loc='on data') Discordance Embeddings do not always agree with cluster results! See cluster 4 above, and note in particular one cell from cluster '1' that is embedded next to the island part of cluster '4'.   <p>We can try to rectify this by using PAGA, which tries to infer dynamic relationships between clusters, to seed an initial embedding for UMAP that reflects overall cluster similarities.</p> <p>In the next cell, we call the following functions</p> <p><code>tl.paga()</code> computes intercluster similarities</p> <p><code>pl.paga()</code> creates an intial embedding based on this</p> <p><code>tl.umap()</code> uses this embedding to start its optimization</p> <p>Let's restart with the cleaned data.</p> In\u00a0[111]: Copied! <pre>adNorm = adClean.copy()\n\n## Norm, HVG, PCA, kNN\nsc.pp.normalize_total(adNorm , target_sum=1e4)\nsc.pp.log1p(adNorm)\nsc.pp.highly_variable_genes(adNorm , min_mean=0.0125, max_mean=6, min_disp=0.25)\nsc.tl.pca(adNorm , use_highly_variable=True)\n\nn_neighbors = 20\nn_pcs = 10\nsc.pp.neighbors(adNorm, n_neighbors=n_neighbors, n_pcs=n_pcs)\nsc.tl.leiden(adNorm,.1)\nsc.tl.paga(adNorm)\nsc.pl.paga(adNorm, plot=False)\nsc.tl.umap(adNorm, 0.25, init_pos='paga')\nsc.pl.umap(adNorm,color=['leiden'], alpha=.75, s=15, legend_loc='on data')\n</pre> adNorm = adClean.copy()  ## Norm, HVG, PCA, kNN sc.pp.normalize_total(adNorm , target_sum=1e4) sc.pp.log1p(adNorm) sc.pp.highly_variable_genes(adNorm , min_mean=0.0125, max_mean=6, min_disp=0.25) sc.tl.pca(adNorm , use_highly_variable=True)  n_neighbors = 20 n_pcs = 10 sc.pp.neighbors(adNorm, n_neighbors=n_neighbors, n_pcs=n_pcs) sc.tl.leiden(adNorm,.1) sc.tl.paga(adNorm) sc.pl.paga(adNorm, plot=False) sc.tl.umap(adNorm, 0.25, init_pos='paga') sc.pl.umap(adNorm,color=['leiden'], alpha=.75, s=15, legend_loc='on data') In\u00a0[112]: Copied! <pre>sc.pl.umap(adNorm , color=markerGenes, ncols=2)\n</pre> sc.pl.umap(adNorm , color=markerGenes, ncols=2) <p>Make a figure that shows the embedding and expression of marker genes side-by-side. Note that I am adding markers for T cell, B cell, and Monocyte sub-types</p> In\u00a0[114]: Copied! <pre>marker_genes_broad_dict = {\n    'B cell': ['CD79A', 'PAX5'],\n    'Dendritic': ['CLEC4C', 'FCER1A'],\n    'Monocyte': ['CSF1R', 'FCGR3A'],\n    'NK cell': ['NKG7', 'GNLY'],\n    'T cell': ['TRAC', 'CD3E'],\n}\n\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,4), gridspec_kw={'wspace':0.25})\nax1_dict = sc.pl.umap(adNorm,color=['leiden'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False)\nax2_dict = sc.pl.dotplot(adNorm, marker_genes_broad_dict, 'leiden', dendrogram=True,ax=ax2, show=False)\nplt.show()\n</pre> marker_genes_broad_dict = {     'B cell': ['CD79A', 'PAX5'],     'Dendritic': ['CLEC4C', 'FCER1A'],     'Monocyte': ['CSF1R', 'FCGR3A'],     'NK cell': ['NKG7', 'GNLY'],     'T cell': ['TRAC', 'CD3E'], }  fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,4), gridspec_kw={'wspace':0.25}) ax1_dict = sc.pl.umap(adNorm,color=['leiden'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False) ax2_dict = sc.pl.dotplot(adNorm, marker_genes_broad_dict, 'leiden', dendrogram=True,ax=ax2, show=False) plt.show() <pre>WARNING: Groups are not reordered because the `groupby` categories and the `var_group_labels` are different.\ncategories: 0, 1, 2, etc.\nvar_group_labels: B cell, Dendritic, Monocyte, etc.\n</pre> In\u00a0[115]: Copied! <pre>sc.tl.leiden(adNorm,.1, restrict_to=[\"leiden\",[\"5\"]])\nsc.tl.dendrogram(adNorm, \"leiden_R\")\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,4), gridspec_kw={'wspace':0.25})\nax1_dict = sc.pl.umap(adNorm,color=['leiden_R'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False)\nax2_dict = sc.pl.dotplot(adNorm, marker_genes_broad_dict, 'leiden_R', dendrogram=True,ax=ax2, show=False)\nplt.show()\n</pre> sc.tl.leiden(adNorm,.1, restrict_to=[\"leiden\",[\"5\"]]) sc.tl.dendrogram(adNorm, \"leiden_R\") fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,4), gridspec_kw={'wspace':0.25}) ax1_dict = sc.pl.umap(adNorm,color=['leiden_R'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False) ax2_dict = sc.pl.dotplot(adNorm, marker_genes_broad_dict, 'leiden_R', dendrogram=True,ax=ax2, show=False) plt.show() <pre>WARNING: Groups are not reordered because the `groupby` categories and the `var_group_labels` are different.\ncategories: 0, 1, 2, etc.\nvar_group_labels: B cell, Dendritic, Monocyte, etc.\n</pre> <p>Cluster 5 is split into 2 clusters now. Both of these sub-clusters express the Monocyte marker CD14, but are distinguished by their expression of dendritic marker FCER1A and the B cell genes CD79A and PAX5. Let's look at the QC metrics to see if that can give us additional hints as to whether these are real cells or are doublets.</p> In\u00a0[116]: Copied! <pre>sc.pl.violin(adNorm, ['total_counts'], groupby='leiden' )\n</pre> sc.pl.violin(adNorm, ['total_counts'], groupby='leiden' ) <p>Cluster 5 has a high number of Total counts. So let's annotate these as 'doublet'.</p> <p>What about the other questionable clusters 4 and 2? Can we refine those?</p> In\u00a0[117]: Copied! <pre>sc.tl.leiden(adNorm,.1, restrict_to=[\"leiden\",[\"2\"]])\nsc.tl.dendrogram(adNorm, \"leiden_R\")\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,4), gridspec_kw={'wspace':0.25})\nax1_dict = sc.pl.umap(adNorm,color=['leiden_R'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False)\nax2_dict = sc.pl.dotplot(adNorm, marker_genes_broad_dict, 'leiden_R', dendrogram=True,ax=ax2, show=False)\nplt.show()\n</pre> sc.tl.leiden(adNorm,.1, restrict_to=[\"leiden\",[\"2\"]]) sc.tl.dendrogram(adNorm, \"leiden_R\") fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,4), gridspec_kw={'wspace':0.25}) ax1_dict = sc.pl.umap(adNorm,color=['leiden_R'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False) ax2_dict = sc.pl.dotplot(adNorm, marker_genes_broad_dict, 'leiden_R', dendrogram=True,ax=ax2, show=False) plt.show() <pre>WARNING: Groups are not reordered because the `groupby` categories and the `var_group_labels` are different.\ncategories: 0, 1, 2,0, etc.\nvar_group_labels: B cell, Dendritic, Monocyte, etc.\n</pre> <p>It looks like 2,0 is T cell, and 2,1 is Natural Killer cell. Note that 2,0 still has a distinct profile as compared to 0.</p> <p>What about cluster 4? And this time, when we do the sub-clustering, let's keep the way that we split up cluster 2.</p> In\u00a0[118]: Copied! <pre>sc.tl.leiden(adNorm,.1, restrict_to=[\"leiden_R\",[\"4\"]])\nsc.tl.dendrogram(adNorm, \"leiden_R\")\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,4), gridspec_kw={'wspace':0.25})\nax1_dict = sc.pl.umap(adNorm,color=['leiden_R'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False)\nax2_dict = sc.pl.dotplot(adNorm, marker_genes_broad_dict, 'leiden_R', dendrogram=True,ax=ax2, show=False)\nplt.show()\n</pre> sc.tl.leiden(adNorm,.1, restrict_to=[\"leiden_R\",[\"4\"]]) sc.tl.dendrogram(adNorm, \"leiden_R\") fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,4), gridspec_kw={'wspace':0.25}) ax1_dict = sc.pl.umap(adNorm,color=['leiden_R'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False) ax2_dict = sc.pl.dotplot(adNorm, marker_genes_broad_dict, 'leiden_R', dendrogram=True,ax=ax2, show=False) plt.show() <pre>WARNING: Groups are not reordered because the `groupby` categories and the `var_group_labels` are different.\ncategories: 0, 1, 2,0, etc.\nvar_group_labels: B cell, Dendritic, Monocyte, etc.\n</pre> <p>Is 4,1 multiplet?</p> In\u00a0[119]: Copied! <pre>sc.pl.violin(adNorm, ['total_counts', 'n_genes_by_counts'], groupby='leiden_R' )\n</pre> sc.pl.violin(adNorm, ['total_counts', 'n_genes_by_counts'], groupby='leiden_R' ) <p>Yes, it looks like 4,1 is similar in these QC profiles to cluster 5.</p> <p>So our updated annotation table is now:</p> cluster markers  of cell type 5 B, Dendritic, Mono doublet 1 Monocyte Monocyte 4,0 Monocyte Monocyte 3 B B-cell 6 Dendritic (B/Mono?) Dendritic cell 7 none Mystery cell 0 T cell T cell 2,0 T cell T cell 2,1 NK cell NK cell <p>Why do we have two Monocyte clusters and two T cells clusters?</p> In\u00a0[120]: Copied! <pre>marker_genes_sub_dict = {\n    'B cell': ['CD79A'],\n    'Dendritic': ['CLEC4C'],\n    'CD14 monocyte': ['CD14'],\n    'CD16 monocyte': ['FCGR3A'],\n    'NK cell': ['GNLY'],\n    'CD4 T cell': ['CD4', 'GATA3'],\n    'CD8 T cell': ['CD8A', 'EOMES']\n}\n\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,4), gridspec_kw={'wspace':0.25})\nax1_dict = sc.pl.umap(adNorm,color=['leiden_R'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False)\nax2_dict = sc.pl.dotplot(adNorm, marker_genes_sub_dict, 'leiden_R', dendrogram=True,ax=ax2, show=False)\nplt.show()\n</pre> marker_genes_sub_dict = {     'B cell': ['CD79A'],     'Dendritic': ['CLEC4C'],     'CD14 monocyte': ['CD14'],     'CD16 monocyte': ['FCGR3A'],     'NK cell': ['GNLY'],     'CD4 T cell': ['CD4', 'GATA3'],     'CD8 T cell': ['CD8A', 'EOMES'] }  fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,4), gridspec_kw={'wspace':0.25}) ax1_dict = sc.pl.umap(adNorm,color=['leiden_R'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False) ax2_dict = sc.pl.dotplot(adNorm, marker_genes_sub_dict, 'leiden_R', dendrogram=True,ax=ax2, show=False) plt.show() <pre>WARNING: Groups are not reordered because the `groupby` categories and the `var_group_labels` are different.\ncategories: 0, 1, 2,0, etc.\nvar_group_labels: B cell, Dendritic, CD14 monocyte, etc.\n</pre> <p>We are close to a final annotation now:</p> cluster markers  of cell type 5 B, Dendritic, Mono doublet 1 Monocyte CD14 Monocyte 4,0 Monocyte CD16 Monocyte 3 B B-cell 6 Dendritic (B/Mono?) Dendritic cell 7 none Mystery cell 0 T cell CD4 T cell 2,0 T cell CD8 T cell 2,1 NK cell NK cell <p>But what is cluster 7? It has low counts. If it is just ambient 'soup', then we would not expect it to have high levels of cell type specific genes. Let's do differential gene expression analysis to see what is upregulated in this cluster.</p> In\u00a0[121]: Copied! <pre>sc.tl.rank_genes_groups(adNorm, use_raw=False, groupby=\"leiden_R\")\n</pre> sc.tl.rank_genes_groups(adNorm, use_raw=False, groupby=\"leiden_R\") <pre>WARNING: Default of the method has been changed to 't-test' from 't-test_overestim_var'\n</pre> In\u00a0[124]: Copied! <pre>sc.pl.rank_genes_groups_dotplot(adNorm, n_genes=5, groupby=\"leiden_R\", dendrogram=True, key='rank_genes_groups')\n</pre> sc.pl.rank_genes_groups_dotplot(adNorm, n_genes=5, groupby=\"leiden_R\", dendrogram=True, key='rank_genes_groups') In\u00a0[125]: Copied! <pre>sc.pl.rank_genes_groups_dotplot(adNorm, n_genes=20, groupby=\"leiden_R\", dendrogram=True, key='rank_genes_groups', groups=['7'])\n</pre> sc.pl.rank_genes_groups_dotplot(adNorm, n_genes=20, groupby=\"leiden_R\", dendrogram=True, key='rank_genes_groups', groups=['7']) <pre>WARNING: Groups are not reordered because the `groupby` categories and the `var_group_labels` are different.\ncategories: 0, 1, 2,0, etc.\nvar_group_labels: 7\n</pre> <p>Although this result could be refined and explored a lot, it is sufficient for us to address our question about the identity of cluster 7 as follows:</p> Help from ChatGPT to annotate cells <p>Now, let's add the annotation to the anndata.obs and discard the other cells</p> cluster markers  of cell type 1 Monocyte CD14 Monocyte 4,0 Monocyte CD16 Monocyte 3 B B-cell 6 Dendritic (B/Mono?) Dendritic cell 7 none Platelet 0 T cell CD4 T cell 2,0 T cell CD8 T cell 2,1 NK cell NK cell In\u00a0[134]: Copied! <pre>tokeep = [\"1\", \"4,0\", \"3\", \"6\", \"7\", \"0\", \"2,0\", \"2,1\"]\nadNorm2 = adNorm.copy()\nadNorm2 = adNorm2[adNorm2.obs['leiden_R'].isin(tokeep)].copy()\nadNorm2.shape\nadNorm2.obs['leiden_R'].value_counts()\n</pre> tokeep = [\"1\", \"4,0\", \"3\", \"6\", \"7\", \"0\", \"2,0\", \"2,1\"] adNorm2 = adNorm.copy() adNorm2 = adNorm2[adNorm2.obs['leiden_R'].isin(tokeep)].copy() adNorm2.shape adNorm2.obs['leiden_R'].value_counts() Out[134]: <pre>leiden_R\n0      3562\n1      3115\n3      1604\n2,0    1032\n2,1     611\n4,0     368\n6        81\n7        60\nName: count, dtype: int64</pre> In\u00a0[135]: Copied! <pre>cell_dict = {'Dendritic': ['6'],\n             'CD14 Monocyte': ['1'],\n             'CD16 Monocyte': [\"4,0\"],\n             'B cell': ['3'],\n             'Platelet': ['7'],\n             'CD4 T cell': ['0'],\n             'CD8 T cell': [\"2,0\"],\n             'NK cell': [\"2,1\"]\n}\n\nnew_obs_name = 'cell_type'\nadNorm2.obs[new_obs_name] = np.nan\n\nfor i in cell_dict.keys():\n    ind = pd.Series(adNorm2.obs.leiden_R).isin(cell_dict[i])\n    adNorm2.obs.loc[ind,new_obs_name] = i\n\nadNorm2.obs['cell_type'] = adNorm2.obs['cell_type'].astype(\"category\")\n</pre> cell_dict = {'Dendritic': ['6'],              'CD14 Monocyte': ['1'],              'CD16 Monocyte': [\"4,0\"],              'B cell': ['3'],              'Platelet': ['7'],              'CD4 T cell': ['0'],              'CD8 T cell': [\"2,0\"],              'NK cell': [\"2,1\"] }  new_obs_name = 'cell_type' adNorm2.obs[new_obs_name] = np.nan  for i in cell_dict.keys():     ind = pd.Series(adNorm2.obs.leiden_R).isin(cell_dict[i])     adNorm2.obs.loc[ind,new_obs_name] = i  adNorm2.obs['cell_type'] = adNorm2.obs['cell_type'].astype(\"category\")   In\u00a0[136]: Copied! <pre>sc.tl.dendrogram(adNorm2, \"cell_type\")\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12,5), gridspec_kw={'wspace':0.4})\nax1_dict = sc.pl.umap(adNorm2,color=['cell_type'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False)\nax2_dict = sc.pl.dotplot(adNorm2, marker_genes_dict, 'cell_type', dendrogram=True,ax=ax2, show=False)\nplt.show()\n</pre> sc.tl.dendrogram(adNorm2, \"cell_type\") fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12,5), gridspec_kw={'wspace':0.4}) ax1_dict = sc.pl.umap(adNorm2,color=['cell_type'], alpha=.75, s=10, legend_loc='on data', ax=ax1, show=False) ax2_dict = sc.pl.dotplot(adNorm2, marker_genes_dict, 'cell_type', dendrogram=True,ax=ax2, show=False) plt.show()  <pre>WARNING: Groups are not reordered because the `groupby` categories and the `var_group_labels` are different.\ncategories: B cell, CD14 Monocyte, CD16 Monocyte, etc.\nvar_group_labels: B cell, Dendritic, Monocyte, etc.\n</pre> In\u00a0[137]: Copied! <pre>sc.pl.pca(adNorm2, color=['cell_type', 'GNLY'], alpha=.75, s=15, projection='3d')\n</pre> sc.pl.pca(adNorm2, color=['cell_type', 'GNLY'], alpha=.75, s=15, projection='3d') In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[138]: Copied! <pre>sc.tl.rank_genes_groups(adNorm2, use_raw=False, groupby=\"cell_type\")\n</pre> sc.tl.rank_genes_groups(adNorm2, use_raw=False, groupby=\"cell_type\") <pre>WARNING: Default of the method has been changed to 't-test' from 't-test_overestim_var'\n</pre> In\u00a0[139]: Copied! <pre>sc.tl.filter_rank_genes_groups(adNorm2, min_fold_change=.7, min_in_group_fraction=.5, max_out_group_fraction=.15)\nsc.pl.rank_genes_groups_dotplot(adNorm2, n_genes=6, groupby=\"cell_type\", dendrogram=True, key='rank_genes_groups_filtered')\n</pre> sc.tl.filter_rank_genes_groups(adNorm2, min_fold_change=.7, min_in_group_fraction=.5, max_out_group_fraction=.15) sc.pl.rank_genes_groups_dotplot(adNorm2, n_genes=6, groupby=\"cell_type\", dendrogram=True, key='rank_genes_groups_filtered') In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/L4_scBasics_v2.html#objectives-for-today","title":"Objectives for today\u00b6","text":"<p>At the end of class, students will be familiar with:</p> <ol> <li>How to use Colab to interact with Python interpreter</li> <li>How to transfer files to/from Colab</li> <li>How to install packages on Colab</li> <li>Basics of Scanpy<ol> <li>annData</li> <li>loading and saving files</li> <li>getting var info</li> <li>getting more help: scanpy docs, tutorials, ChatGPT</li> </ol> </li> <li>Quality control</li> <li>Normalization</li> <li>Dimension reduction</li> <li>Cell-cell distance</li> <li>Unsupervised clustering</li> <li>Differential gene expression</li> <li>Cell annotation</li> </ol>"},{"location":"notebooks/L4_scBasics_v2.html#what-we-did-last-time","title":"What we did last time\u00b6","text":"<p>Last time we discussed gene expression, how to measure gene expression in lots of single cells, noted that this is an imperfect surrogate for cell state/identity</p>"},{"location":"notebooks/L4_scBasics_v2.html#outline-for-today","title":"Outline for today\u00b6","text":"<p>Here is what we are going to talk about:</p> <ol> <li>How this is going to work, and what we expect from you, and what you can expect from us</li> <li>Nature of the data: some biological motivation + CellRanger output</li> <li>Intro to Colab/Jupyter</li> <li>How to analyze scRNAseq data</li> <li>Format for HW1 -- What you should turn in, its format</li> </ol>"},{"location":"notebooks/L4_scBasics_v2.html#how-this-will-work","title":"How this will work\u00b6","text":"<p>How this is going to work today. We will break things down into 2-5 minutes bites, where I will tell you about the step, then I'll stop and give you a few minutes to try it on your own. If you would like, please feel free to pair up, at most groups of 3 for this BUT feel no obligation to do so!!! Also, I am not going to ask anyone to show us your work, answer questions, etc. Today is just about getting you hands on experience with these types of analyses so that you are prepared for the first Homework.</p>"},{"location":"notebooks/L4_scBasics_v2.html#background-on-the-data","title":"Background on the data\u00b6","text":"<p>Let's start with some background + motivation for the data set that we are going to analyze: hematopoietic cells from peripheral blood.</p>"},{"location":"notebooks/L4_scBasics_v2.html#hematopoiesis","title":"Hematopoiesis\u00b6","text":"Traditional model of hematopoiesis. Image from Slack 2017 <p>These cells are produced in the bone marrow and then move into the vascular so that they can move about the body and perform their functions (transport oxygen, clot, do adaptive and innate immune things).</p>"},{"location":"notebooks/L4_scBasics_v2.html#peripheral-blood-mononuclear-cells-pbmcs","title":"Peripheral blood mononuclear cells (PBMCs)\u00b6","text":"<p>It is possible to enrich for what are called PBMCs from vein by subjecting sample to density gradient centrifugation. This enrichs for cells that have one, round nucleus, and excludes cells that do not have nuclie, or that have multi-lobed structures. PBMCs typically contain:</p> <p>... several classes of immune cells, including T cells (~70%), B cells (~15%), monocytes (~5%), dendritic cells (~1%) and natural killer (NK) cells (~10%)     --  Sen et al 2019</p> <p>and</p> <p>... The CD3+ lymphocytes are composed of CD4+ and CD8+ T cells, roughly in a 2:1 ratio.     -- Kleiveland, 2015</p>"},{"location":"notebooks/L4_scBasics_v2.html#bio-questions-for-the-day","title":"Bio question(s) for the day\u00b6","text":"<ul> <li>What does scRNAseq estimate as their relative proportion? and how does it compare to the estimate above?</li> <li>To what extent does cell type composition vary between samples?</li> <li>Are there other genes that are better at distinguishing between these populations than marker genes listed below?</li> <li>How many cells do you need to reliably detect a sub-population?</li> </ul>"},{"location":"notebooks/L4_scBasics_v2.html#data","title":"Data\u00b6","text":"<p>10X Genomics scRNA-seq on human PBMCs</p>"},{"location":"notebooks/L4_scBasics_v2.html#sample-1","title":"Sample 1\u00b6","text":"<ul> <li>http://cf.10xgenomics.com/samples/cell-exp/1.1.0/pbmc3k/pbmc3k_filtered_gene_bc_matrices.tar.gz</li> </ul>"},{"location":"notebooks/L4_scBasics_v2.html#sample-2","title":"Sample 2\u00b6","text":"<ul> <li>https://colab.research.google.com/corgiredirector?site=https%3A%2F%2Fcf.10xgenomics.com%2Fsamples%2Fcell-exp%2F6.1.0%2F20k_PBMC_3p_HT_nextgem_Chromium_X%2F20k_PBMC_3p_HT_nextgem_Chromium_X_filtered_feature_bc_matrix.h5</li> <li>20k Human PBMCs, 3\u2019 HT v3.1, Chromium X</li> <li>Sourced from a healthy female donor</li> <li>23,837 cells</li> <li>35,000 reads per cell</li> <li>Filtered data in .h5 format</li> </ul>"},{"location":"notebooks/L4_scBasics_v2.html#cellranger","title":"CellRanger\u00b6","text":"<p>CellRanger is the program that converts sequencing reads into gene expression counts.</p> CellRanger flow chart from 10X genomics"},{"location":"notebooks/L4_scBasics_v2.html#jupyter-basics","title":"Jupyter basics\u00b6","text":"<p>Connect to Colab: https://colab.research.google.com/</p>"},{"location":"notebooks/L4_scBasics_v2.html#install-scanpy","title":"Install scanpy\u00b6","text":""},{"location":"notebooks/L4_scBasics_v2.html#fetch-data-files","title":"Fetch data file(s)\u00b6","text":""},{"location":"notebooks/L4_scBasics_v2.html#scanpy-basics","title":"Scanpy basics\u00b6","text":""},{"location":"notebooks/L4_scBasics_v2.html#load-packages","title":"load packages\u00b6","text":""},{"location":"notebooks/L4_scBasics_v2.html#load-sample-1","title":"Load Sample 1\u00b6","text":""},{"location":"notebooks/L4_scBasics_v2.html#getting-information-about-functions","title":"Getting information about functions\u00b6","text":"<p>You can get info about functions using</p> <p>help(functionName)</p> <p>or</p> <p>?functionName</p>"},{"location":"notebooks/L4_scBasics_v2.html#inspecting-the-data-gross-properties","title":"Inspecting the data -- gross properties\u00b6","text":""},{"location":"notebooks/L4_scBasics_v2.html#anndata","title":"AnnData\u00b6","text":"<p>AnnData is a Python package that defines a data structure designed to efficiently store large data sets like scRNA-seq.</p> AnnData schema. See Resouces below for link to documentation"},{"location":"notebooks/L4_scBasics_v2.html#slicing-or-subsetting","title":"Slicing or subsetting\u00b6","text":"<p>Get a small subset of the data</p>"},{"location":"notebooks/L4_scBasics_v2.html#gene-counts","title":"Gene counts\u00b6","text":"<p>So, where is the data?</p>"},{"location":"notebooks/L4_scBasics_v2.html#meta-data","title":"meta data\u00b6","text":"<p>for cells, see .obs</p> <p>for genesm see .var</p>"},{"location":"notebooks/L4_scBasics_v2.html#loc","title":".loc\u00b6","text":"<p>Use .loc function to index based with labels</p>"},{"location":"notebooks/L4_scBasics_v2.html#quality-control-qc","title":"Quality Control (QC)\u00b6","text":"<p>We want to find putative doublets and low quality cell barcodes and exclude them. We also can remove genes that are not detected in vast majority of cells. pp.calculate_qc_metrics() will calcualte a set of metrics for both obs and var that can be used for QC filtering. It can also take inputs to specify other, custom metrics to compute. Below, we use it to compute the fraction total umis in each cell that are mitochondrially encoded or that code for ribosomal genes.</p>"},{"location":"notebooks/L4_scBasics_v2.html#visualize","title":"Visualize\u00b6","text":"<p>Take a look some typical QC values across these data</p>"},{"location":"notebooks/L4_scBasics_v2.html#normalization","title":"Normalization\u00b6","text":"<p>Simple library size scaling, then log transform. There are many other ways to do correct for cell-to-cell technical variation, for example different cell lysis efficiencies, but this method is good enough.</p>"},{"location":"notebooks/L4_scBasics_v2.html#highly-variable-genes-hvg","title":"Highly variable genes (HVG)\u00b6","text":"<p>It is common practice to limit some parts of analysis to those variables/genes that exhibit some degree of variation in their values across the data. We call these highly variable genes, or HVG for short. To find these, calculate some gene statistics, which when combined with thresholds below, determine which genes are considered HVG. These metrics are mean expression and dispersion (variance / mean). Variance is defined as the expected squared deviation of gene expression. The normalized dispersion is calculated by scaling based on a bin of mean expression.</p>"},{"location":"notebooks/L4_scBasics_v2.html#pca","title":"PCA\u00b6","text":"<p>There are two facts that make PCA a good tool for analzying scRNAseq data: 1.) genes are expressed in coordinated fashion, meaning that many have correlated expression patterns. 2.) Second scRNAseq data is noisy.</p> <p>PCA allows us to reduce a high dimensional data set into a lower dimension in which much of the total variation is maintained. To understand PCA, you need to know linear algebra. In essence, it identifies sets of linear combinations of genes in such a way that they uncorrelated and explain most variation in the data. The function call does the following:</p> <ul> <li>compute the covariance matrix (correlation between each pair of genes)</li> <li>finding eigenvectors (directions of axes that maximize that variance), orthogonal to each other</li> </ul> <p>Later, we find select a number num_pcs as the number of PCs that contribute most to the total variation on our data. We use these PCs to compute cell-to-cell distances for embedding and for clustering of cells.</p>"},{"location":"notebooks/L4_scBasics_v2.html#marker-genes","title":"Marker genes\u00b6","text":"<p>Here PBMC cell types and some genes that have been used to identify them: Monocytes: CD14, CD68, LYZ Dendritic: CLEC4C, FLT3 NK cells: GNLY, NCAM1 B cells: CD19, CD79A, CD79B T cells: CD3D, CD3E, TRAC, TRBC</p>"},{"location":"notebooks/L4_scBasics_v2.html#pca-loadings","title":"PCA Loadings\u00b6","text":"<p>Where are PCs (i.e. loadings -- the contribution of each gene to each PC) stored in anndata? .varm (see figure of anndata way above)?</p>"},{"location":"notebooks/L4_scBasics_v2.html#knn-cell-cell-distances","title":"kNN cell-cell distances\u00b6","text":"<p>The k-nearest neighbor graph generates an adjacency matrix by finding, for each cell, the k cells that are closest to it. This helps to reduce noise in computing cell-cell distances or similarities and is important for embedding the cells in a 2D space, and for community detection algorithms. Two arguments are n_neighbors, or k, and the number of PCs to use when computing cell-cell distances.</p>"},{"location":"notebooks/L4_scBasics_v2.html#visualization-of-cell-cell-similarities","title":"Visualization of cell-cell similarities\u00b6","text":""},{"location":"notebooks/L4_scBasics_v2.html#umap-embedding","title":"UMAP embedding\u00b6","text":"<p>This an elaboration on the t-SNE embedding approach. Both of these methods try to project cells into a reduced (typically 2) dimensional coordinate system while maintaining both the global and local structure of the high dimensional space of the data (i.e. cells that are distant from each other high dimensions should still be distant in the reduced embedding; same is true for cells that are near each other). The distances come from the kNN graph.</p>"},{"location":"notebooks/L4_scBasics_v2.html#unsupervised-clustering","title":"Unsupervised clustering\u00b6","text":"<p>Let's try to assign cells to distinct groups or clusters based on the cell-to-cell distances. Leiden and Louvain are examples of community detection methods that perform this task by searching for the group assignment that maximize within group similarity (which is equivalent to within group edges of a knn graph) and to minimize between group similarity.</p>"},{"location":"notebooks/L4_scBasics_v2.html#cluster-annotation","title":"Cluster annotation\u00b6","text":"<p>We can walk down the rows of the dotplot and guess at the cell types of some of these clusters based on the specificty of marker expression:</p> cluster markers  of cell type 5 B, Dendritic, Mono ??? 1 Monocyte Monocyte 4 Monocyte, T ??? 3 B B-cell 6 Dendritic (B/Mono?) Dendritic cell 7 none Mystery cell 0 T cell T cell 2 NK/T ??? <p>Some clusters are ambiguous because they express markers of more than one cell type. This could be due to the cluster containing &gt; 1 cell type, or because the cell barcodes are doublets. If the former, then we should be able to sub cluster them. Let's try this.</p> <p>Clusters to refine are 5, 4, and 2.</p>"},{"location":"notebooks/L4_scBasics_v2.html#differential-gene-expression","title":"Differential gene expression\u00b6","text":""},{"location":"notebooks/L4_scBasics_v2.html#differential-expression-analysis","title":"Differential expression analysis\u00b6","text":"<p>Let's identify genes that are preferenntially expressed in each cluster versus all the others as a final step to annotate these clusters and to remove ones that are likely to be doublets.</p>"},{"location":"notebooks/L4_scBasics_v2.html#dot-plot-of-differentially-expressed-genes","title":"Dot plot of differentially expressed genes\u00b6","text":"<p>First, we will apply a filter so that we only display genes that meet additional criteria beyond statistical: fold change, % expressed in cluster, % expressed in other cells</p>"},{"location":"notebooks/L4_scBasics_v2.html#resources","title":"Resources\u00b6","text":""},{"location":"notebooks/L4_scBasics_v2.html#tools","title":"Tools\u00b6","text":"<ul> <li>Colab<ul> <li>https://colab.research.google.com/</li> </ul> </li> <li>Jupyter<ul> <li>https://jupyter.org/</li> </ul> </li> <li>CellRanger<ul> <li>https://www.10xgenomics.com/support/software/cell-ranger/latest/advanced/cr-barcode-rank-plot</li> <li>https://www.10xgenomics.com/support/software/cell-ranger/latest/algorithms-overview/cr-gex-algorithm</li> </ul> </li> </ul>"},{"location":"notebooks/L4_scBasics_v2.html#literature","title":"Literature\u00b6","text":"<ul> <li>Best practices<ul> <li>best practices in sc analysis online book</li> <li>paper associated with the above online book</li> </ul> </li> <li>Scanpy<ul> <li>https://scanpy.readthedocs.io/en/stable/</li> <li>https://scanpy.readthedocs.io/en/stable/tutorials.html</li> <li>https://scanpy-tutorials.readthedocs.io/en/latest/pbmc3k.html</li> <li>https://scanpy-tutorials.readthedocs.io/en/latest/plotting/advanced.html</li> <li>https://scanpy-tutorials.readthedocs.io/en/latest/plotting/core.html</li> </ul> </li> <li>AnnData<ul> <li>https://anndata.readthedocs.io/en/latest/tutorials/notebooks/getting-started.html</li> <li>https://anndata.readthedocs.io/en/latest/index.html</li> </ul> </li> <li>QC<ul> <li>https://genomebiology.biomedcentral.com/articles/10.1186/s13059-020-02136-7</li> </ul> </li> </ul>"}]}